---
layout: post
title: JDK 1.2 解读
category: JDK
description: JDK 1.2 更新解读 JDK在1.2版本把名字改为了J2SE，1.2版本中最重要的一大看点是引入了集合框架 Collections framework。这是最早的集合包，里面只定义了一些简单的集合，源码实现也非常简单，源码位置在java.util包下。
---

JDK在1.2版本把名字改为了J2SE，所以在6版本之前都叫这个名字，J2SE 1.2。

1.2版本中最重要的一大看点是引入了集合框架 Collections framework。这是最早的集合包，里面只定义了一些简单的集合，源码实现也非常简单，源码位置在java.util包下。

# Collection

![](/assets/images/jdk/collection1.2.png)

集合框架的顶层接口，定义了集合的一些基本操作，比如size、isEmpty、contains、iterator、toArray、add、remove、clear。抽象类`AbstractCollection`实现了`Collection`集合，简化了集合实现步骤。实现了一些基本的方法，比如contains、toArray、remove、clear、toString方法，当然子类也可以重载这些方法，实现自己的定义。

本文主要介绍基于List接口实现的的ArrayList、LinkedList集合，基于Map接口实现的的HashMap、TreeMap和WeakHashMap集合，基于Set接口实现的的HashSet、TreeSet集合。

## List

### AbstractList

列表抽象类`AbstractList`定义一个支持随机访问数据的列表实现方式。抽象类里面最重要的是实现`Iterator`接口和新增了一个listIterator方法：
* iterator方法，创建并返回了一个Itr对象。 内部类`Itr`实现了`Iterator`接口，重写了hasNext，next，remove，checkForComodification方法，支持单向遍历集合。
* listIterator方法，创建并返回了一个从下标0开始的ListItr对象。内部类`ListItr`继承`Itr`并实现了`ListIterator`集合的迭代器接口。`ListIterator`接口继承了`Iterator`接口并新增了基于列表操作的方法hasPrevious，previous，nextIndex，previousIndex等方法，支持双向遍历集合。

最后一个内部类是`SubList`子列表类，基于当前列表构建出的子列表。但是注意，这个子列表是通过对当前列表的引用来实现的，所以会一直持有当前集合的对象引用。而且只要当前列表一被修改，对其子列表的任何操作都是报错抛出异常。

**iterator()**
迭代方法，创建一个Itr对象返回
> 创建一个Itr对象返回，Itr对象实现了Iterator接口
> Iterator迭代器定义了三个方法，Itr类实现了这三个方法

#### AbstractList.Itr

**Itr.hasNext()**
判断是否还有元素
> 通过cursor当前游标来判断List是否还有元素
> 每调用一次next方法，cursor++，只要cursor不等于size就说明还有元素

{% highlight java %}

public boolean hasNext() {
	return cursor != size();
}

{% endhighlight %}

**Itr.next()**
返回下一个元素
> 1. 迭代器是直接访问实现类的元素，根据当前游标位置获取指定坐标的元素
> 2. 使用迭代器是不允许修改List的，所以会检查modCount是否修改过；如果修改过，直接抛异常；
> 3. 最后游标++，返回获取到的元素。

{% highlight java %}

public Object next() {
	try {
		// 调用实现类的get方法，获取指定坐标的元素
		Object next = get(cursor);
		// 检查迭代过程中，List是否有被修改过
		checkForComodification();
		// 游标++，记录最新一次next方法返回的元素坐标
		lastRet = cursor++;
		return next;
	} catch(IndexOutOfBoundsException e) {
		checkForComodification();
		throw new NoSuchElementException();
	}
}

final void checkForComodification() {
	// 检查基础ArrayList里的modCount是否被修改过
	if (modCount != expectedModCount)
		throw new ConcurrentModificationException();
	}
}
{% endhighlight %}

**Itr.remove()**
删除上一次next方法返回的元素，要先调用next才能调用remove。
> 1. 迭代器删除元素也是直接调用实现类的remove方法，将上一次next方法返回的元素删除；

{% highlight java %}

public void remove() {
	if (lastRet == -1)
		throw new IllegalStateException();

	try {
		// 调用实现类的remove方法
		AbstractList.this.remove(lastRet);
	if (lastRet < cursor)
		cursor--;
	lastRet = -1;

	int newModCount = modCount;
	if (newModCount - expectedModCount > 1)
		throw new ConcurrentModificationException();
	// 重置modCount值
	expectedModCount = newModCount;
	} catch(IndexOutOfBoundsException e) {
		throw new ConcurrentModificationException();
	}
}

{% endhighlight %}

注意：Iterator的next和remove方法在代码执行时都会对modCount值进行检查，防止基础List数组被操作过，导致不一致。

**在使用迭代器遍历集合的过程中，要删除元素，必须使用迭代器的remove方法，不能直接使用集合提供的remove方法**
> 因为iterator每次next方法时，都会检查modCount是否被修改过。ArrayList的remove方法会修改modCount的值。

Iterator接口只提供了在遍历列表的过程中删除元素，不能新增元素，如果要新增可以使用ListItr类，ListItr继承了Itr，提供了新增方法。

#### AbstractList.ListItr

ListItr继承了Itr类并实现了ListIterator接口。ListIterator接口继承了Iterator接口，在Iterator接口的基础上又新增了几个方法。ListIterator接口提供了倒序遍历List的功能，并且实现了可以在迭代过程中新增或修改元素。
- hasPrevious 双向遍历，判断是否有上一个元素，该功能可以实现List的反转，即倒序遍历
- previous 返回上一个元素
- set 修改当前元素值
- add 新增元素

**ListItr.hasPrevious()**
判断上一个是否还有元素，即是否是List头
> 只要cursor不等于0即可

{% highlight java %}

public boolean hasPrevious() {
	return cursor != 0;
}

{% endhighlight %}

**ListItr.previous()**
返回上一个元素
> 1. --cursor即可获取上一个元素的坐标，然后通过实现类的get方法即可获取到上一个元素

{% highlight java %}

public Object previous() {
	try {
		Object previous = get(--cursor);
		checkForComodification();
		lastRet = cursor;
		return previous;
	} catch(IndexOutOfBoundsException e) {
		checkForComodification();
		throw new NoSuchElementException();
	}
}
{% endhighlight %}

**ListItr.set()**
修改当前值，即上一次调用next方法返回的元素值
> 1. 调用实现类的set方法，修改lastRet坐标的值即可
> 2. 因为对List进行了操作，所以set方法也要记得更新modCount值

{% highlight java %}

public void set(Object o) {
	if (lastRet == -1)
		throw new IllegalStateException();

	try {
		// 通过lastRet值来更新元素
		AbstractList.this.set(lastRet, o);

	int newModCount = modCount;
	if (newModCount - expectedModCount > 1)
		throw new ConcurrentModificationException();
	// 记得要更新modCount值
	expectedModCount = newModCount;
	} catch(IndexOutOfBoundsException e) {
		throw new ConcurrentModificationException();
	}
}

{% endhighlight %}

**ListItr.add()**
新增元素，这里要注意新增的位置，即上一次调用next方法返回的元素值的位置后面
> 1. 调用实现类的add方法，将新元素添加到cursor++位置即可
> 2. 因为对List进行了操作，所以add方法也要记得更新modCount值

{% highlight java %}

public void add(Object o) {
	try {
		AbstractList.this.add(cursor++, o);
		lastRet = -1;

		int newModCount = modCount;
		if (newModCount - expectedModCount > 1)
		    throw new ConcurrentModificationException();
		expectedModCount = newModCount;
	    } catch(IndexOutOfBoundsException e) {
		throw new ConcurrentModificationException();
	    }
	}
}

{% endhighlight %}

### ArrayList

基于数组实现的动态列表，继承了`AbstractList`并实现了`List`接口。size，get，set操作的时间复杂度都是常量时间，add操作的时间复杂度接近常量。ArrayList的所有操作的时间复杂度几乎都是接近常量，所以是一个非常高效的列表。每个ArrayList都有一个容量capacity，指定数组的大小，该容量值会随着数组元素的增加自动调整。

ArrayList是线程不安全的，非同步的，所以对于多线程操作会出现同步问题。Vector是线程安全的列表，也是基于数组的动态列表，所有操作的方法都加上了synchronized修饰符。

**核心方法介绍**

**构造函数**
> ArrayList内部是使用数组作为存储结构的，在构造函数里实例化了一个Object[]数组
{% highlight java %}
private transient Object elementData[]; // 元素实际存储在这个数组中

public ArrayList() {
	this(10); // 默认数组容量值为10
}

public ArrayList(int initialCapacity) {
    super();    // AbstractList构造方法为空
    this.elementData = new Object[initialCapacity]; // 创建ArrayList对象的时候就会立即初始化一个数组
}
{% endhighlight %}

**toArray()**
将ArrayList以数组形式返回输出
> toArray()返回的是新数组，并不是直接把内部的`elementData[]`数组返回。使用System.arraycopy方法将内部数组数据复制到新的数组，然后把新创建的数组返回。这样对新数组的修改操作不会影响到现有数组。

{% highlight java %}
// 将集合以数组形式返回 这里会创建一个新的数组返回，不会直接将列表集合里的elementData数组返回。
public Object[] toArray() {
	Object[] result = new Object[size]; // 创建一个新的数组，容量为ArrayList的容量
	System.arraycopy(elementData, 0, result, 0, size);  // 使用System.arraycopy将当前列表复制到新的数组。
	return result;
}
{% endhighlight %}

**add(Object o)**
将对象添加到List中
> 1. add方法首先对数组的容量大小进行检查，看是否需要扩容；如果不需要直接将对象添加到数组末尾，结束返回true；
> 2. 如果需要扩容，则先计算新的容量值，默认扩大1.5倍；然后判断新计算出来的值是否满足条件；如果还是不满足，则直接使用新增容量值；最后将现有数组内容全部复制到新数组上，通过System.arraycopy方法复制数组；
> 3. 容量扩容完后，将对象添加到数组末尾，结束返回true；

{% highlight java %}
public boolean add(Object o) {
	ensureCapacity(size + 1);  // 动态调整数组容量大小，确认容量空间够
	elementData[size++] = o; // 将新元素添加到数组末尾
	return true;
}

// ensureCapacity会自动扩容，所以只有调用了这个方法，一定会确保数组的容量是够用的
public void ensureCapacity(int minCapacity) {
	modCount++; // 记录对集合的每次操作，在迭代器中就根据这个遍历值来判断集合是否被修改过。
	int oldCapacity = elementData.length;
	if (minCapacity > oldCapacity) {
	    Object oldData[] = elementData;
	    int newCapacity = (oldCapacity * 3)/2 + 1;  // 如果集合容量不够了，就进行扩容
    	    if (newCapacity < minCapacity)
		newCapacity = minCapacity;  // 如果容量还是不够，就直接用指定的容量minCapacity
	    elementData = new Object[newCapacity];  // 创建一个使用新容量的新的数组
	    System.arraycopy(oldData, 0, elementData, 0, size); // 使用System.arraycopy将旧数组拷贝到新的数组
	}
    // 如果当前容量够，就直接结束返回
}
{% endhighlight %}

**add(int index, Object element)**
将元素添加到指定位置
> 1. 首先对index位置进行范围检查；
> 2. 然后对数组容量进行检查；调用ensureCapacity方法，确保数组容量够，如果不够会自动完成扩容；
> 3. 其次将在index后的所有元素往后移动一位；通过System.arraycopy方法实现元素后移；
> 4. 最后将值添加到index位置，size++

{% highlight java %}
// 将新元素添加到指定位置
public void add(int index, Object element) {
	if (index > size || index < 0)
	    throw new IndexOutOfBoundsException(
		"Index: "+index+", Size: "+size);

	ensureCapacity(size+1);  // Increments modCount!! 确保容量够
	System.arraycopy(elementData, index, elementData, index + 1,
			 size - index); // 将当前位置以及后面的所有元素都往后移动一格
	elementData[index] = element; // 将新元素添加到当前位置
	size++;
}
{% endhighlight %}

**remove(int index)**
删除指定位置的元素，删除完后要将后面的元素都往前移动一位。
> 1. 首先检查index范围；
> 2. 然后将index后的元素都往前移动一位；通过System.arraycopy方法实现；
> 3. 其次将最后一位元素位置null，size--;

{% highlight java %}
// 删除指定位置的元素
public Object remove(int index) {
	RangeCheck(index);

	modCount++; // 只要有对集合操作，modCount都会增加
	Object oldValue = elementData[index];

	int numMoved = size - index - 1;
	if (numMoved > 0)
	    System.arraycopy(elementData, index+1, elementData, index,
			     numMoved); // 将当前位置后面的所有元素都往前移动一格
	elementData[--size] = null; // Let gc do its work 最后一格元素置为null，方便垃圾收集器回收

	return oldValue;
}
{% endhighlight %}

**clear()**
clear方法并不会缩减数组容量，而是把数组所有元素设置为null，size设置为0.

{% highlight java %}
// 清空列表集合
public void clear() {
	modCount++; // 清空操作也会记录

	// Let gc do its work
	for (int i = 0; i < size; i++)
	    elementData[i] = null; // 这里是通过遍历方式，将数组里的所有元素都置为null。

	size = 0;
}

public Object get(int index) {
	RangeCheck(index);

	return elementData[index];
}
{% endhighlight %}

**iterator()**
迭代方法，是直接调用父类的实现
> 1. iterator()内部创建了一个Itr对象，Itr对象实现了Iterator接口

除了以上几个基本的方法，ArrayList还提供了一些实现：
- int indexOf(Object elem); 返回第一个匹配到的元素坐标，需要遍历数组获取对应元素下标
- int lastIndexOf(Object elem); 返回最后一个匹配到的元素坐标，需要倒序遍历数组获取对应元素下标
- Object clone(); 克隆当前ArrayList实例，实例化一个新数组，然后将元素全部拷贝到新数组
- Object[] toArray(Object a[]); toArray可以输出到指定数组里，这里需要对指定数组的容量值进行判断是否需要扩容，然后再将元素复制到指定数组
- addAll(Collection c)； 直接添加一个集合到数组末尾，这里操作与添加单个元素类似，先检查数组容量是否需要扩容，扩容完后通过迭代方式将集合添加到数组中
- removeRange(int fromIndex, int toIndex); 删除指定范围内的元素，将toIndex后的元素移动到fromIndex的位置
- writeObject/readObject; 用于序列化操作，这里注意Object elementData[]数组是被一个transient变量修饰，序列化时不会将transient变量进行序列化

#### 遍历集合的三种方式

有三种方式遍历ArrayList：
- for 使用ArrayList自身属性和方法完成遍历
- Iterator 使用AbstractList.Itr迭代器完成遍历
- forEach 内部实现就是用Iterator，所以本质也是Iterator方式迭代

#### 遍历集合并删除元素的两种方式

1. for 倒序遍历删除

{% highlight java %}

public void remove(ArrayList<String> list) {

	for(int i = list.size() - 1; i > 0; i++) {
		if("StringA".equals(list.get(i))) {
			list.remove(i);
		}
	}

}

{% endhighlight %}

2. Iterator 遍历删除

{% highlight java %}

public void remove(ArrayList<String> list) {

	Iterator iterator = list.iterator();
	while(iterator.hasNext()) {
		if("StringA".equals(iterator.next())) {
			iterator.remove();
		}
	}

}

{% endhighlight %}

### AbstractSequentialList

支持顺序访问数据的抽象顺序列表集合，继承`AbstractList`抽象类，并重写了操作方法，所有的操作都基于`public abstract ListIterator listIterator(int index);`来实现。iterator方法内部是调用`AbstractList`实现的ListItr内部对象。

### LinkedList

双向链表，可以用于实现栈、队列或双端队列等数据结构。链表也是非线程安全的，非同步的。

!!!这里后续要改进下，不要直接贴和解读代码，要先把思路讲解一下，在看代码。比如链表提供了什么功能，每个功能做什么用的，然后再看具体代码是怎么实现的!!!

LinkedList内部是使用双端链表进行保存的，addFirst将元素添加到链表头，addLast将元素添加到链表尾部，add方法默认将元素添加到链表尾部，remove方法将指定元素从链表中删除，clear清空链表。

{% highlight java %}

private transient Entry header = new Entry(null, null, null); // 初始会创建一个空的Entry节点，链表节点都是用Entry来表示的。记住该版本的链表只有header，当next指针指向header的时候，表示链表尾。
private transient int size = 0;	// 链表长度

public LinkedList() {
    header.next = header.previous = header; // 初始化的时候会构建一个空的循环链表
}

// 链表节点，链表的组成部分
private static class Entry {
	Object element; // 节点值
	Entry next; // 下一个节点
	Entry previous; // 上一个节点

	Entry(Object element, Entry next, Entry previous) {
	    this.element = element;
	    this.next = next;
	    this.previous = previous;
	}
}

// 移除当前节点  
// head <--> Entry A <--> Entry B <--> Entry C <--> head(the one)         
private void remove(Entry e) {
	if (e == header)
	    throw new NoSuchElementException();

	e.previous.next = e.next;   // 将当前元素的上一个元素的next指针指向当前元素的next对象
	e.next.previous = e.previous;   // 将当前元素的下一个元素的previous指针指向当前元素的previous对象
	size--;
	modCount++;

    // 这样操作完之后，当前元素的next指针还会指向next对象，previous指针还会指针previous对象。这里只改变了上一个和下一个元素的指针指向。并不会改变自己的。所以1.2中即使remove元素，元素对象还是不会被回收。
	// 2018/10/17 jdk1.5优化了这个现象，将e.next = e.previous = null 以及 e.element = null
}

// 根据坐标获取元素
public Object get(int index) {
        return entry(index).element;
}


private Entry entry(int index) {
    if (index < 0 || index >= size)
        throw new IndexOutOfBoundsException("Index: "+index+
                                            ", Size: "+size);
    Entry e = header;
    if (index < size/2) { // 一次2分查找，从前半部分或者后半部分开始查找
        for (int i = 0; i <= index; i++)
            e = e.next;
    } else {
        for (int i = size; i > index; i--)
            e = e.previous;
    }
    return e;
}
{% endhighlight %}

# Map

![](/assets/images/jdk/map1.2.png)

键值对映射集合，用于取代Dictionary的。Map接口定义基本接口：get，put，remove，keySet，values，entrySet，并定义了一个Entry接口，用于表示Map中的节点。`AbstractMap`抽象类实现了Map的基本接口，主要用到的是keySet，values，将entrySet重写了抽象方法，由具体Map实现类来实现。

## HashMap

Map接口的实现，允许键和值为null，无序的Map。跟HashTable结构很像，除了HashMap是非同步的，以及允许null值。get和put操作的时间复杂度是常量值。初始容量值 initial capacity 和 加载因子 load factor 影响HashMap性能，因为这两个参数决定Map的容量大小和扩容时机。

{% highlight java %}

// 数组
private transient Entry table[]; 

// 单向链表
private static class Entry implements Map.Entry {
	int hash;
	Object key;
	Object value;
	Entry next;

	Entry(int hash, Object key, Object value, Entry next) {
		this.hash = hash;
		this.key = key;
		this.value = value;
		this.next = next;
	}
}

{% endhighlight %}

HashMap基于数组和链表结构来存储元素，数组结构表示HashMap的容量值，链表用于存储实际的元素。内部实现了一个自定义的HashIterator迭代器。

put(Object key, Object value)逻辑，1.先判断该key是否在map中，如果在则直接更新value，然后返回旧的value；（计算key的hash值，根据hash值得到在table[]数组中的坐标，然后遍历该坐标的Entry链表。通过hash值和equals都相等判断key是否存在。如果存在则新value直接替换旧的value，然后返回旧的value值）2.否则，新增key/value值，先判断map容量是否需要扩容，扩容后重置计算key在table[]数组中的下标，然后将key插入entry链表头部。

{% highlight java %}

private int threshold; // 根据capacity和loadFactor计算出来的，用于扩容HashMap用的

private float loadFactor;

private transient int modCount = 0; // 记录Map的修改次数，迭代的时候可以用来判断集合是否被修改

public HashMap(int initialCapacity, float loadFactor) {
	if (initialCapacity < 0)
	    throw new IllegalArgumentException("Illegal Initial Capacity: "+
                                               initialCapacity);
	if (loadFactor <= 0)
		throw new IllegalArgumentException("Illegal Load factor: "+
											loadFactor);
	if (initialCapacity==0)
		initialCapacity = 1;

	this.loadFactor = loadFactor;
	table = new Entry[initialCapacity];     // 初始化的时候会创建默认一个Entry数组（JDK1.8版是在put操作初始化的）
	threshold = (int)(initialCapacity * loadFactor);    // 计算出Map扩容值，当Map的元素值超过这个阈值时，Map就会进行扩容
}

// 判断值是否在Map中，要遍历整个Map
// 所以containsValue非常耗时
public boolean containsValue(Object value) {
	Entry tab[] = table;

	if (value==null) {
	    for (int i = tab.length ; i-- > 0 ;)
			for (Entry e = tab[i] ; e != null ; e = e.next)
				if (e.value==null)
					return true;
	} else {
		// 后续遍历
	    for (int i = tab.length ; i-- > 0 ;)    // 循环遍历Entry数组，每个Entry是一个链表结构
			for (Entry e = tab[i] ; e != null ; e = e.next) // 再循环判断Entry链表，判断值是否相等
				if (value.equals(e.value)) // 通过equals方法判断值是否相等
					return true;
	}

	return false;
}

// 判断键是否在集合中，通过hash获取key所在的Entry数组下标，然后判断该下标的Entry链表即可。
// contains逻辑与get一模一样
public boolean containsKey(Object key) {
	Entry tab[] = table;
        if (key != null) {
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;   // 获取key的Entry数组下标
            for (Entry e = tab[index]; e != null; e = e.next)   // 遍历Entry链表，判断键是否相等
                if (e.hash==hash && key.equals(e.key))
                    return true;
        } else {
            for (Entry e = tab[0]; e != null; e = e.next)
                if (e.key==null)
                    return true;
        }

	return false;
}

// 通过键获取值，通过hash获取key所在Entry数组下标，然后遍历该下标的Entry链表，返回值。注意：同一个下标的Entry链表，hash值可能是相同的
public Object get(Object key) {
	Entry tab[] = table;

    if (key != null) {
        int hash = key.hashCode();  // 获取键的hash值
        int index = (hash & 0x7FFFFFFF) % tab.length;
        for (Entry e = tab[index]; e != null; e = e.next)
            if ((e.hash == hash) && key.equals(e.key))  //  遍历Entry链表，判断Entry的hash和键是否相等
                return e.value;
	} else {
        for (Entry e = tab[0]; e != null; e = e.next)
            if (e.key == null)
                return e.value;
    }

	return null;
}

// 对Map进行扩容，扩容到更大的数组，需要重新计算下标
private void rehash() {
	int oldCapacity = table.length;
	Entry oldMap[] = table;

	int newCapacity = oldCapacity * 2 + 1;
	Entry newMap[] = new Entry[newCapacity];

	modCount++;
	threshold = (int)(newCapacity * loadFactor);
	// 并发rehash问题的引入，这里创建完新集合就直接赋值给全局table了。
	// 多线程同时rehash
	table = newMap;

	// 取出每一个元素，重新计算下标，插入新数组。
	for (int i = oldCapacity; i-- > 0;) { // 倒序遍历Entry数组
	    for (Entry old = oldMap[i] ; old != null ; ) {  // 顺序遍历Entry链表
			Entry e = old;
			old = old.next;

			int index = (e.hash & 0x7FFFFFFF) % newCapacity;    // 重新计算新的数组下标
			// 以下两行代码在并发扩容的时候会出现死循环，JDK1.8之后改为尾插入，可以避免死循环问题，但是在并发put的时候会出现数据覆盖问题。
			e.next = newMap[index]; // 将Entry添加到链表头，这样扩容完后，是不是就改变的元素的顺序，对的。
			newMap[index] = e;
	    }
	}
}

// 总结下put的逻辑：
// key null和非null的处理逻辑不同
// key null，添加到tab数组第一个位置
// key 非null，先获取key的hash值，计算得出hash对于数组tab的下标值index，取出tab[index]的链表
// 通过hash和equals方法遍历链表值是否与key相等，如果相等则直接替换，并返回旧值。
public Object put(Object key, Object value) {
	// Makes sure the key is not already in the HashMap.
	Entry tab[] = table;
    int hash = 0;
    int index = 0;

    if (key != null) {
        hash = key.hashCode(); // 取得key的hashCode值，注意hashCode值有可能相同
        index = (hash & 0x7FFFFFFF) % tab.length;   // 计算key的数组下标
        for (Entry e = tab[index] ; e != null ; e = e.next) {   // 遍历Entry链表，这里从tab数组中取出的元素是一个链表结构。
            if ((e.hash == hash) && key.equals(e.key)) {    // 如果key已存在，则value覆盖，并返回old的值
                Object old = e.value;
                e.value = value;
                return old;
            }
        } // 这里for循环的结果是：1）得出结论，key在这个Entry链表中不存在，可以直接插入；2）Entry为null。
    } else {
		// key允许为null
		// 默认数组第一个位置放key为null的元素
        for (Entry e = tab[0] ; e != null ; e = e.next) {
            if (e.key == null) { // key为null的比对是直接用==，所以理论上tab[0]有且只要一个链表节点
                Object old = e.value;
                e.value = value;
                return old;
            }
        }
    }

	// 只有当map的size值发生变化，modCount值才会变化
	modCount++; // key不存在map中，为新的key，则modCount++，表示Map要增加了

	// 如果集合当然容量超过阈值，则进行扩容
	if (count >= threshold) {
	    // Rehash the table if the threshold is exceeded
	    rehash();

		tab = table;
		index = (hash & 0x7FFFFFFF) % tab.length;
	}

	// Creates the new entry. 创建新的链表节点Entry
	Entry e = new Entry(hash, key, value, tab[index]); // 创建新的Entry，插入到Entry链表头
	// 这里并发执行会有问题，两个线程同时执行，其中一个线程的数据会丢失
	tab[index] = e; // new Entry方法，会将现有Entry链表添加到新Entry的后面。
	count++;
	return null;
}

public Object remove(Object key) {
	Entry tab[] = table;

    if (key != null) {
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;

		// 所以这里就是一个链表基本删除操作
		// 单链表删除，要保存上一个元素
        for (Entry e = tab[index], prev = null; e != null;  // prev变量用来保存上一个Entry
                prev = e, e = e.next) {
            if ((e.hash == hash) && key.equals(e.key)) {
                modCount++; // 做删除操作，集合size有变，所以modCount++
                if (prev != null)   // 如果prev不为空，直接将prev的next指针指向要删除元素的next对象
                    prev.next = e.next;
                else    // 如果prev为null，说明e为链表头结点，则将链表头指向e的next对象
                    tab[index] = e.next;

                count--;
                Object oldValue = e.value;
                e.value = null;
                return oldValue;
            }
        }
    } else {
        for (Entry e = tab[0], prev = null; e != null;  // key为null，默认保存在Entry数组的第一个位置
                prev = e, e = e.next) {
            if (e.key == null) {
                modCount++;
                if (prev != null)
                    prev.next = e.next;
                else
                    tab[0] = e.next;

                count--;
                Object oldValue = e.value;
                e.value = null;
                return oldValue;
            }
        }
    }

	return null;
}

// 清空map
public void clear() {
	Entry tab[] = table;
	modCount++;
	for (int index = tab.length; --index >= 0; )    // 遍历Entry数组
	    tab[index] = null;  // 将Entry链表置为null
	count = 0;
}
{% endhighlight %}

## TreeMap

有序的HashMap，基于红黑树实现的Map，实现了SortedMap接口。时间复杂度O(lgn)Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。（MySQL索引是B+树）

应用场景以及和B树的区别：
红黑树多用在内排（内部排序，即全放在内存中的），微软STL的map和set的内部实现就是红黑树。
B树多用在外排（内存里放不下，大部分数据存储在外存上时），因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少。B树是为了提高磁盘或外部存储设备查找效率而产生的一种多路平衡查找树。B+树为B树的变形结构，用于大多数数据库或文件系统的存储而设计。

在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。
反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。

在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定。


红黑树的约束条件是：
1. 节点要么是红色要么是黑色。
2. 根节点固定是黑色。
3. 红色父节点的两个子节点必须是黑色。
4. 从叶子节点到根节点的所有路径必须包含相同数量的黑节点。

红黑树平衡调整操作：
1. 变换颜色。
2. 旋转节点。

红黑色操作技巧：
1. 除根节点，每次新插入的节点都是红色。
2. 插入时如果父节点是黑色，不用调整树，直接插入。
3. 当前节点为左孩子时，如果父节点X是红色，父节点的兄弟节点Y也是红色（祖父节点P都是黑色） --> 将X，Y的变黑，P变红，然后将当前节点指向P，从P开始重新计算平衡。
4. 当前节点为右孩子时，如果父节点X是红色，父节点的兄弟节点Y是黑色（祖父节点P都是黑色） --> 将当前节点指向X，然后以X节点做左旋转操作，再从X开始重新计算平衡。
5. 当前节点为左孩子时，如果父节点X是红色，父节点的兄弟节点Y是黑色（祖父节点P都是黑色） --> 将X变黑，P变红，然后将当前节点指向P，以P节点做右旋转操作，再将P变黑，再从P开始重新计算平衡。

{% highlight java %}

private transient Entry root = null;

static class Entry implements Map.Entry {
	Object key;
	Object value;
	Entry left = null;
	Entry right = null;
	Entry parent;
	boolean color = BLACK;
}

{% endhighlight %}


{% highlight java %}

private Comparator comparator = null;   // 比较器，用于比较两个元素的大小来决定顺序位置

private transient Entry root = null;    // 红黑树，树根

public boolean containsKey(Object key) {
	return getEntry(key) != null;
}

private Entry getEntry(Object key) {
	Entry p = root;
	while (p != null) {
	    int cmp = compare(key,p.key);   // 比较key的大小
	    if (cmp == 0)   // 这里使用二分查找，小于根节点，就从左子树迭代查找；大于根节点，从右子树查找；知道节点等于返回
		return p;
	    else if (cmp < 0)
		p = p.left;
	    else
		p = p.right;
	}
	return null;
}

private int compare(Object k1, Object k2) {
	return (comparator==null ? ((Comparable)k1).compareTo(k2)   // 如果没有指定比较器，就用元素自带的比较方法
				 : comparator.compare(k1, k2)); // 否则用比较器实现的比较方法
}

// 查找元素是否在集合中，这里要遍历树，使用前序遍历整颗树。
public boolean containsValue(Object value) {
    return (root==null ? false :
            (value==null ? valueSearchNull(root)
                    : valueSearchNonNull(root, value)));
}

private boolean valueSearchNonNull(Entry n, Object value) {
    // Check this node for the value
    if (value.equals(n.value))
        return true;

    // Check left and right subtrees for value
    return (n.left  != null && valueSearchNonNull(n.left, value)) ||    // 前序遍历树查找值
            (n.right != null && valueSearchNonNull(n.right, value));
}

// 返回集合中的第一个元素，采用前序遍历
public Object firstKey() {
        return key(firstEntry());
}

private Entry firstEntry() {
	Entry p = root;
	if (p != null)
	    while (p.left != null)  // 一直遍历左子树直到左叶子节点
		p = p.left;
	return p;
}

// 返回集合中的最后一个元素，采用后序遍历
public Object lastKey() {
    return key(lastEntry());
}

private Entry lastEntry() {
	Entry p = root;
	if (p != null)
	    while (p.right != null)  // 一直遍历右子树直到右叶子节点
		p = p.right;
	return p;
}
{% endhighlight %}

{% highlight java %}

public Object put(Object key, Object value) {
	Entry t = root;

	if (t == null) {
	    incrementSize();
	    root = new Entry(key, value, null); // 如果树为空树，则创建第一个root节点
	    return null;
	}

	while (true) {
	    int cmp = compare(key, t.key);
	    if (cmp == 0) {
		    return t.setValue(value);   // 如果key相同，直接替换value值
	    } else if (cmp < 0) {   // 如果小于，就放到左子树
            if (t.left != null) {
                t = t.left;
            } else {
                incrementSize();    // 如果是左子树的叶子节点，就新建一个节点
                t.left = new Entry(key, value, t);  // 将节点插入该位置
                fixAfterInsertion(t.left);  // 然后确保树平衡，尝试旋转树节点到平衡
                return null;
            }
	    } else { // cmp > 0 // 如果大于，就放到右子树
		    if (t.right != null) {
		        t = t.right;
		    } else {
                incrementSize();
                t.right = new Entry(key, value, t);
                fixAfterInsertion(t.right); // 确认树平衡
                return null;
            }
	    }
	}
}

/** From CLR **/
private void fixAfterInsertion(Entry x) {
	x.color = RED;

	while (x != null && x != root && x.parent.color == RED) {
	    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
		Entry y = rightOf(parentOf(parentOf(x)));
		if (colorOf(y) == RED) {
		    setColor(parentOf(x), BLACK);
		    setColor(y, BLACK);
		    setColor(parentOf(parentOf(x)), RED);
		    x = parentOf(parentOf(x));
		} else {
		    if (x == rightOf(parentOf(x))) {
			x = parentOf(x);
			rotateLeft(x);
		    }
		    setColor(parentOf(x), BLACK);
		    setColor(parentOf(parentOf(x)), RED);
		    if (parentOf(parentOf(x)) != null) 
			rotateRight(parentOf(parentOf(x)));
		}
	    } else {
		Entry y = leftOf(parentOf(parentOf(x)));
		if (colorOf(y) == RED) {
		    setColor(parentOf(x), BLACK);
		    setColor(y, BLACK);
		    setColor(parentOf(parentOf(x)), RED);
		    x = parentOf(parentOf(x));
		} else {
		    if (x == leftOf(parentOf(x))) {
			x = parentOf(x);
			rotateRight(x);
		    }
		    setColor(parentOf(x),  BLACK);
		    setColor(parentOf(parentOf(x)), RED);
		    if (parentOf(parentOf(x)) != null) 
			rotateLeft(parentOf(parentOf(x)));
		}
	    }
	}
	root.color = BLACK;
}

{% endhighlight %}

## WeakHashMap

这里先介绍下Java里的四种引用类型
* 强引用 日常的Java对象都是强引用，只有将引用指向null，对象才会被回收
* 软引用 内存不足时会被回收
* 弱引用 只要发生垃圾回收，就会被回收
* 虚引用 只要发生垃圾回收，就会被回收。不过在回收前会被加入到一个队列里。可以操作该队列重新引用该对象。

WeakHashMap表示key为虚引用WeakKey，继承了WeakReference。

{% highlight java %}

static private class WeakKey extends WeakReference {
		private int hash;	/* Hashcode of key, stored here since the key
					may be tossed by the GC */
}

// 内部使用HashMap
private Map hash;

// 垃圾回收队列，当weakkey要被回收时，会先加入到该队列。
private ReferenceQueue queue = new ReferenceQueue();

{% endhighlight %}

## Set

元素结合，集合内元素唯一、不重复。

## HashSet

基于HashMap实现的，

{% highlight java %}

private transient HashMap map;  // 基于HashMap实现，内部其实只是用HashMap来保存元素

private static final Object PRESENT = new Object();   // 表示HashMap的value，因为Set不是键值对集合。

// 添加元素到Set中
public boolean add(Object o) {
	return map.put(o, PRESENT)==null;   // 用HashMap保存，key为元素值，value为固定值object
}

public boolean remove(Object o) {
	return map.remove(o)==PRESENT;  // 整个HashMap的value都是同一个对象PRESENT
}

{% endhighlight %}