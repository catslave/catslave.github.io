---
layout: post
title: 数据结构与算法分析入门
category: Algorithms
description: 数据结构和基本算法
---

## 数据结构

### 数组

### 链表

### 队列

### 栈

### 树

### 堆

### 图

## 排序算法

### 冒泡排序

> 从后往前排序，先从最后一个元素开始，一个个的向前比较大小，比前面元素小就交换两者的位置，每比较一轮就能确定一个最小数。

时间查找复杂度为O(n2)。

### 插入排序

> 从第一个元素开始，与后面每一个元素进行比较，记录最小的元素值和位置，比较完一轮后将最小的元素替换到第一位。

时间查找复杂度为O(n2)。

### 选择排序

> 从第一个元素开始，先拿前两个元素进行大小比较，排完序后选择第三个元素开始与前两个已排序的元素比较，以此类推。

时间查找复杂度为O(n2)。

### 堆排序

> 插入有序，构建堆时进行排序，顶节点元素最小。

时间查找复杂度为O(nlogn)。

### 归并排序

> 将数组两两拆分到最小，然后将排好序的数组进行合并。

时间查找复杂度为O(nlogn)。

### 快速排序

> 选择一个元素作为基点，比基点小的放左边，大的放右边。然后再对左边的数组进行排序，选择一个基点，以此类推。

时间查找复杂度为O(nlogn)。

堆排序、归并排序、快速排序数据结构上都是树型，树的深度为logn，所以三个排序的时间查找复杂度都为O(nlogn)

## 查找算法

### 线性查找

> 从第一个元素开始，以此与后面每一个元素进行比较。

时间查找复杂度为O(n2)。

### 二分查找

> 前提：数组是排序的。每次计算中间坐标，比较中间位置元素的大小，小于从左边数组比较，大于从右边数组查找。

时间查找复杂度为O(logn)。

## 图

### 广度优先查找

> 逐层遍历，适合用队列实现，FIFO特性。

### 深度优先查找

> 迭代遍历

### 最小路径查找

> 两种算法实现：贝尔曼-福特算法、迪克斯特拉算法。

## 其它算法

### 最大公约数（欧几里得）

### 素数

### 字符串类算法问题

字符串类相关的算法题：
1. 子串
2. 回文

提示：字符串本质上是一个字符数组，所以字符串类的解题思路要结合数组来考虑。

#### 反转字符串（reverse string）

定义：就是把字符串所有字符倒序。

解题思路：字符串是一个字符数组，可以要实现字符的反转，只要把头尾的字符进行交换即可，只要处理完一半的字符另一半也自然就处理完了。

字符的交换需要一个临时字符变量来存储交换值。

示例：
> 这里要补上代码实现；

#### 回文（palindrome）

定义：回文就是正读和反读都一样的字符串。

解题思路：利用头尾指针，即双指针技术来实现。
> 1. 如果两个指针的字符不相同，直接返回false；
> 2. 如果两个指针的字符相同，同时更新头、尾指针，然后循环比较，直到头、尾指针相遇。

示例：
> 这里要补上代码实现；

#### 前缀树/字典树/单词查找树（Trie Tree）

字典树是一种存储结构，把字符串拆成单个字符，以树的方式存储起来。
> 1. 根节点不包含字符
> 2. 每个节点包含一个字符
> 3. 有相同前缀的单词在同一个前缀节点树下
> 4. 从根节点到某一节点，路径上经过的字符连起来，就是该节点对应的字符串
> 5. 每个节点最多26个子节点（英文26个字符，即树的最大广度为26。）

字典树的两种基本操作分别是建树和查询。建树就是把一个新的单词插入到字典树里，查询操作就是查询给定的单词是否在字典树上。

Trie树注意给定单词的字符长度，如果字符串都非常长（例如64位的MD5）那Trie树的深度会是64层。

#### KMP

KMP适合子串查找，字典树适合全串匹配

## 剑指offer

所有代码实现要分析时间复杂度和空间复杂度。

### 数据结构类

#### LinkedList

##### 003-从尾到头打印链表

**思路**：

利用栈实现倒序输出，通过遍历链表将每一个节点入栈，然后再遍历输出栈即可。

**代码**：

##### 014-链表中倒数第k个结点

**思路**：

利用双指针（快指针和慢指针），快指针向前移动K个位置，然后快、慢指针一起向前移动，直到快指针为null，慢指针的位置就是第k个节点。

**代码**：

##### 015-反转链表

**思路**：

逐个反转每一个节点。
> 新建一个头节点（newHead），总是指向下一个节点。节点反转需要保存上一个节点（preNode）、下一个节点（nextNode）、当前节点（curNode）

反转做的2个动作：
1. newHead.next = curNode.next; // 头节点指向下一个节点
2. curNode.next = preNode; // 当前节点指向上一个节点
3. preNode = curNode; // 上一节点指向当前节点

**伪代码**

初始化：
newHead.next = head.next; // 新头节点指向下一个节点
preNode.next = null; // 头节点上一个节点为null
head.next = preNode; // 当前节点指向上一个节点

curNode = head.next;

反转：
while(curNode.next != null) {
    newHead.next = curNode.next; // 1.
    curNode.next = preNode; // 2.
    preNode = curNode; // 3.
}

##### 016-合并两个或k个有序链表

**思路**：

两个链表从头开始比较大小，P1小于P2，取出P1，继续P1+与P2比，小的节点+1直到末尾。


##### 025-复杂链表的复制

**复杂链表定义**：单向链表节点，同时节点还有一个额外指针指向任意节点或者null。
> 节点有两个指针，一个next指向下一个节点，另一个sibling指向任意节点。

**思路**：

有3套思路：
第一套，时间复杂度O(n2)
第二套，时间复杂度O(n)，空间复杂度O(n)
第三套，时间复杂度O(n)

目前只理解的第二套：

第一遍正常复制旧链表的next指针节点，遍历链表创建新的链表，同时把旧->新节点存放到HashMap中做映射。

第二遍遍历旧链表的sibling指针节点，到HashMap中根据旧节点找到新节点，直接将新链表的sibling指向新的节点。


##### 036-两个链表的第一个公共节点

**第一个公共节点**：这两个链表后面是共用一个链表。

**思路**：

1. 先计算两个链表长度的差N；
2. 长的链表先走N个节点；
3. 两个链表同时继续遍历走节点，直到两个节点相同。

##### 055-链表中环的入口结点

**思路**：

1. 使用两个指针，一个指针指向链表头节点，另一个指针指向快、慢指针相遇的节点。
2. 两个指针同时出发，直到它们相遇则为入口节点。


**链表环的相关问题**
1. 链表是否有环：通过快、慢指针判断，如果两个指针相遇说明有环（快、慢指针相遇时，慢指针还没有走完）。
2. 如果有环，找环的入口节点
3. 如果有环，求环的节点个数
4. 如果有环，求链表长度

##### 056-删除链表中重复的结点

**思路**：

准备两个指针（快、慢），两指针节点相等，快指针+1，再比较，如果还是相等，快指针继续+1，不相等，慢指针指向快指针位置，快指针+1继续判断。

#### Tree
#### Stack&Queue
#### Heap
#### HashTable
#### 图

### 算法类

#### 斐波那契数列
#### 搜索算法
#### 全排列
#### 动态规划
#### 回溯
#### 排序
#### 位运算
#### 其他算法
