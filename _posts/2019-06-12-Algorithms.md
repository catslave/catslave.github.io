---
layout: post
title: 数据结构与算法分析入门
category: Algorithms
description: 数据结构和基本算法
---

# 数据结构

## 数组

## 链表

## 队列

## 栈

## 树

## 堆

## 图

# 排序算法

## 冒泡排序

> 从后往前排序，先从最后一个元素开始，一个个的向前比较大小，比前面元素小就交换两者的位置，每比较一轮就能确定一个最小数。

时间查找复杂度为O(n2)。

## 插入排序

> 从第一个元素开始，与后面每一个元素进行比较，记录最小的元素值和位置，比较完一轮后将最小的元素替换到第一位。

时间查找复杂度为O(n2)。

## 选择排序

> 从第一个元素开始，先拿前两个元素进行大小比较，排完序后选择第三个元素开始与前两个已排序的元素比较，以此类推。

时间查找复杂度为O(n2)。

## 堆排序

> 插入有序，构建堆时进行排序，顶节点元素最小。

时间查找复杂度为O(nlogn)。

## 归并排序

> 将数组两两拆分到最小，然后将排好序的数组进行合并。

时间查找复杂度为O(nlogn)。

## 快速排序

> 选择一个元素作为基点，比基点小的放左边，大的放右边。然后再对左边的数组进行排序，选择一个基点，以此类推。

时间查找复杂度为O(nlogn)。

堆排序、归并排序、快速排序数据结构上都是树型，树的深度为logn，所以三个排序的时间查找复杂度都为O(nlogn)

# 查找算法

## 线性查找

> 从第一个元素开始，以此与后面每一个元素进行比较。

时间查找复杂度为O(n2)。

## 二分查找

> 前提：数组是排序的。每次计算中间坐标，比较中间位置元素的大小，小于从左边数组比较，大于从右边数组查找。

时间查找复杂度为O(logn)。

# 图

## 广度优先查找

> 逐层遍历，适合用队列实现，FIFO特性。

## 深度优先查找

> 迭代遍历

## 最小路径查找

> 两种算法实现：贝尔曼-福特算法、迪克斯特拉算法。

# 其它算法

## 最大公约数（欧几里得）

## 素数