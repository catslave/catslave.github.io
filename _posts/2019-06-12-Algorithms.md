---
layout: post
title: 数据结构与算法分析入门
category: Algorithms
description: 数据结构和基本算法
---

## 数据结构

### 数组

### 链表

### 队列

### 栈

### 树

### 堆

### 图

## 排序算法

### 冒泡排序

> 从后往前排序，先从最后一个元素开始，一个个的向前比较大小，比前面元素小就交换两者的位置，每比较一轮就能确定一个最小数。

时间查找复杂度为O(n2)。

### 插入排序

> 从第一个元素开始，与后面每一个元素进行比较，记录最小的元素值和位置，比较完一轮后将最小的元素替换到第一位。

时间查找复杂度为O(n2)。

### 选择排序

> 从第一个元素开始，先拿前两个元素进行大小比较，排完序后选择第三个元素开始与前两个已排序的元素比较，以此类推。

时间查找复杂度为O(n2)。

### 堆排序

> 插入有序，构建堆时进行排序，顶节点元素最小。

时间查找复杂度为O(nlogn)。

### 归并排序

> 将数组两两拆分到最小，然后将排好序的数组进行合并。

时间查找复杂度为O(nlogn)。

### 快速排序

> 选择一个元素作为基点，比基点小的放左边，大的放右边。然后再对左边的数组进行排序，选择一个基点，以此类推。

时间查找复杂度为O(nlogn)。

堆排序、归并排序、快速排序数据结构上都是树型，树的深度为logn，所以三个排序的时间查找复杂度都为O(nlogn)

## 查找算法

### 线性查找

> 从第一个元素开始，以此与后面每一个元素进行比较。

时间查找复杂度为O(n2)。

### 二分查找

> 前提：数组是排序的。每次计算中间坐标，比较中间位置元素的大小，小于从左边数组比较，大于从右边数组查找。

时间查找复杂度为O(logn)。

## 图

### 广度优先查找

> 逐层遍历，适合用队列实现，FIFO特性。

### 深度优先查找

> 迭代遍历

### 最小路径查找

> 两种算法实现：贝尔曼-福特算法、迪克斯特拉算法。

## 其它算法

### 最大公约数（欧几里得）

### 素数

### 字符串类算法问题

字符串类相关的算法题：
1. 子串
2. 回文

提示：字符串本质上是一个字符数组，所以字符串类的解题思路要结合数组来考虑。

#### 反转字符串（reverse string）

定义：就是把字符串所有字符倒序。

解题思路：字符串是一个字符数组，可以要实现字符的反转，只要把头尾的字符进行交换即可，只要处理完一半的字符另一半也自然就处理完了。

字符的交换需要一个临时字符变量来存储交换值。

示例：
> 这里要补上代码实现；

#### 回文（palindrome）

定义：回文就是正读和反读都一样的字符串。

解题思路：利用头尾指针，即双指针技术来实现。
> 1. 如果两个指针的字符不相同，直接返回false；
> 2. 如果两个指针的字符相同，同时更新头、尾指针，然后循环比较，直到头、尾指针相遇。

示例：
> 这里要补上代码实现；

#### 前缀树/字典树/单词查找树（Trie Tree）

字典树是一种存储结构，把字符串拆成单个字符，以树的方式存储起来。
> 1. 根节点不包含字符
> 2. 每个节点包含一个字符
> 3. 有相同前缀的单词在同一个前缀节点树下
> 4. 从根节点到某一节点，路径上经过的字符连起来，就是该节点对应的字符串
> 5. 每个节点最多26个子节点（英文26个字符，即树的最大广度为26。）

字典树的两种基本操作分别是建树和查询。建树就是把一个新的单词插入到字典树里，查询操作就是查询给定的单词是否在字典树上。

Trie树注意给定单词的字符长度，如果字符串都非常长（例如64位的MD5）那Trie树的深度会是64层。

#### KMP

KMP适合子串查找，字典树适合全串匹配

## 剑指offer

所有代码实现要分析时间复杂度和空间复杂度。

### 数据结构类

#### LinkedList

8道题

##### 003-从尾到头打印链表

**思路**：

利用栈实现倒序输出，通过遍历链表将每一个节点入栈，然后再遍历输出栈即可。

**代码**：

##### 014-链表中倒数第k个结点

**思路**：

利用双指针（快指针和慢指针），快指针向前移动K个位置，然后快、慢指针一起向前移动，直到快指针为null，慢指针的位置就是第k个节点。

**代码**：

##### 015-反转链表

**思路**：

逐个反转每一个节点。
> 新建一个头节点（newHead），总是指向下一个节点。节点反转需要保存上一个节点（preNode）、下一个节点（nextNode）、当前节点（curNode）

反转做的2个动作：
1. newHead.next = curNode.next; // 头节点指向下一个节点
2. curNode.next = preNode; // 当前节点指向上一个节点
3. preNode = curNode; // 上一节点指向当前节点

**伪代码**

初始化：
newHead.next = head.next; // 新头节点指向下一个节点
preNode.next = null; // 头节点上一个节点为null
head.next = preNode; // 当前节点指向上一个节点

curNode = head.next;

反转：
while(curNode.next != null) {
    newHead.next = curNode.next; // 1.
    curNode.next = preNode; // 2.
    preNode = curNode; // 3.
}

##### 016-合并两个或k个有序链表

**思路**：

两个链表从头开始比较大小，P1小于P2，取出P1，继续P1+与P2比，小的节点+1直到末尾。


##### 025-复杂链表的复制

**复杂链表定义**：单向链表节点，同时节点还有一个额外指针指向任意节点或者null。
> 节点有两个指针，一个next指向下一个节点，另一个sibling指向任意节点。

**思路**：

有3套思路：
第一套，时间复杂度O(n2)
第二套，时间复杂度O(n)，空间复杂度O(n)
第三套，时间复杂度O(n)

目前只理解的第二套：

第一遍正常复制旧链表的next指针节点，遍历链表创建新的链表，同时把旧->新节点存放到HashMap中做映射。

第二遍遍历旧链表的sibling指针节点，到HashMap中根据旧节点找到新节点，直接将新链表的sibling指向新的节点。


##### 036-两个链表的第一个公共节点

**第一个公共节点**：这两个链表后面是共用一个链表。

**思路**：

1. 先计算两个链表长度的差N；
2. 长的链表先走N个节点；
3. 两个链表同时继续遍历走节点，直到两个节点相同。

##### 055-链表中环的入口结点

**思路**：

1. 使用两个指针，一个指针指向链表头节点，另一个指针指向快、慢指针相遇的节点。
2. 两个指针同时出发，直到它们相遇则为入口节点。


**链表环的相关问题**
1. 链表是否有环：通过快、慢指针判断，如果两个指针相遇说明有环（快、慢指针相遇时，慢指针还没有走完）。
2. 如果有环，找环的入口节点
3. 如果有环，求环的节点个数
4. 如果有环，求链表长度

##### 056-删除链表中重复的节点

**思路**：

准备两个指针（快、慢），两指针节点相等，快指针+1，再比较，如果还是相等，快指针继续+1，不相等，慢指针指向快指针位置，快指针+1继续判断。

#### Tree

15道题

**前、中、后序遍历**

这里首先要理解二叉树的前、中、后序遍历，以及如果根据其中两个遍历还原二叉树。
> 预备知识要先知道如何输出一颗树的前、中、后序遍历，然后再根据前、中、后序遍历如何还原。只要先明白了这两个输出和还原就没问题了。

二叉树遍历概念：
- 前序遍历：根、左、右 --> 前序遍历 root {左右子树}
- 中序遍历：左、根、右 --> 中序遍历 {左子树集合} root {右子树集合}
- 后序遍历：左、右、根 --> 后序遍历 {左右子树} root

二叉树还原：
- 前、中序遍历还原
> 1. 前序，第一个节点是根节点（父节点）
> 2. 根据前序确认的根节点，在中序中拆分 {左子树} 根节点 {右子树}
> 3. 把第一颗树就可以画出来了。
> 4. 开始还原 {左子树}，把前序和中序的{左子树}部分单独出来，对{左子树}进行1/2步骤的判断，然后画出3。循环处理{左子树}和{右子树}。
- 中、后序遍历还原
> 1. 后序，最后一个节点是根节点（父节点）
> 2. 根据后序确认的根节点，在中序中拆分 {左子树} 根节点 {右子树}
> 3. 把第一颗树就可以画出来了。
> 4. 开始还原 {左子树}，把后序和中序的{左子树}部分单独出来，对{左子树}进行1/2步骤的判断，然后画出3。循环处理{左子树}和{右子树}。

- 前、后序遍历无法还原，因为无法确认左、右子树

**DFS深度优先查找**

**BFS广度优先查找**

##### 004-重建二叉树

**重建**：根据二叉树的前序、中序顺序还原二叉树。

**思路**：

##### 017-树的子结构

**题意**：判断B树是否是A树的子树

**思路**：
1. 先在A中找到B的根节点R；
2. 然后从R节点开始递归判断AB树的每一个节点是否相等；
> 如果两个节点值不相等直接返回false；
> 如果B树节点为空，返回true；
> 如果A树节点为空，返回false；

##### 018-二叉树的镜像

**题意**：镜像就是所有节点左右翻转，AB - BA

**思路**：
递归将根节点每个左右子节点进行交换。

##### 022-从上往下打印二叉树

**题意**：树的层次遍历

**思路**：
遍历二叉树，使用队列存储，然后输出队列。

##### 023-二叉搜索树的后序遍历序列

**题意**：判断数组是否是某二叉树的后序遍历结果

二叉查找树特点：左子树值 < 根节点值 < 右子树值 

**思路**：
1. 利用二叉查找树的特点，后序遍历最后一位是根节点
2. 遍历数组，查找第一个比根节点值大的位置，则，该位置左边是左子树，右边是右子树。
3. 设计上左子树的值都要把根节点小，右子树的值都要比根节点大。
4. 递归左右子树，执行1/2/3判断。

##### 024-二叉树中和为某一值的路径

**题意**：给定一个值，打印二叉树中节点值和为该值的路径

这是一道DFS深度优先查找，也是一道前序遍历查找。

**思路**：

##### 026-二叉搜索树与双向链表
##### 038-二叉树的深度
##### 039-平衡二叉树
##### 057-二叉树的下一个结点
##### 058-对称的二叉树
##### 059-按之字形顺序打印二叉树
##### 060-把二叉树打印成多行
##### 061-序列化二叉树
##### 062-二叉搜索树的第k个结点


#### Stack&Queue
#### Heap
#### HashTable
#### 图

### 算法类

#### 斐波那契数列
#### 搜索算法
#### 全排列
#### 动态规划
#### 回溯
#### 排序
#### 位运算
#### 其他算法

## LeetCode

### Array

#### two sum

相关知识点：

1. 空间换时间，利用map来解题，要注意map去重问题
2. 注意给定数组是否有序的，可以利用Arrays.sort对数组进行排序
3. 双指针技术（也叫快慢指针）

##### 1. Two Sum

题意：给定一个整数数组，和一个目标值，找出数组中和为目标值的两个整数。

思路：

1. 暴力法：两个嵌套for循环，直接遍历数组。时间复杂度O(n2)，空间复杂度O(1)
2. 用空间换时间，先将数组转为hashMap，然后一个for循环，判断值是否在map中存在即可。时间复杂度O(n2)，空间复杂度O(1)
3. 也是**利用hashMap**，一遍for循环，循环内同时map.put。

##### 15. 3Sum

题意：给定一个整数数组，找出3个元素和为0的所有可能子数组

思路：

1. 暴力法：三个嵌套for循环，时间复杂度O(n3)，超时
2. 与上一题思路一样，空间换时间，减少一个for循环，将数组转为map，第二个for循环从map里面取值判断。时间复杂度O(n2)，空间复杂度O(n)
3. 先对数组排序，再利用**双指针**技术一遍for循环加内嵌while比较。三个指针，第一个指针用于分割成两个子数组，从0开始，指针坐标的为待比较值，右边为待比较数组。另外两个指针对待比较数组进行遍历计算。
> 即先确定第一个元素后，在剩下的数组里查找两数之和。

##### 16. 3Sum Closest

题意：与上题类似，求最接近给定值的三个元素之和。
> 也就是找出三元素之和最小的（绝对值最小的）

思路：

1. 先对**数组排序**，然后**双指针技术**确定第一个元素，在剩下数组中查找两数之和与目标值的绝对值最小的坐标。

##### 167. Two Sum II - Input array is sorted

题意：给定一个有序的整数数组，和一个目标值，找出数组中和为目标值的两个整数。
> 注意这个数组是有序的，所以数组的查找可以利用二分查找。

思路：

常见解法有双指针、二分查找。

1. 双指针：头、尾两个指针相加，小于目标值，左指针+1，大于目标值，右指针+1。
2. 二分查找：确定第一个元素，然后对剩下的数组进行二分查找，找出值相加等于目标值的元素。


#### 快慢双指针

##### 26. Remove Duplicates from Sorted Array

题意：只要返回长度，无需输出唯一数组，同时不能利用额外空间。所以这一题只要统计长度即可。

思路：

快慢指针：慢指针指向第一个元素，最终慢指针就是唯一数组的长度。慢指针与快指针进行比较，相等，快指针+1；不相等，慢指针+1，同时将快指针当前数字复制到慢指针位置，然后快指针也+1 。一直循环比较移动直到快指针结束，最终慢指针就是唯一数组的长度。

##### 27. Remove Element

思路：

慢指针存储最终的值，快指针开始遍历，比较元素值与目标值大小，如果相等，快指针+1；如果不相等，将快指针元素赋值到慢指针位置，然后快慢指针都+1，继续快指针的比较。最终慢指针前面的就是所得的数组。

##### 80. Remove Duplicates from Sorted Array II

题意：类似26题，不过这次是允许元素重复2次，所以是要移除重复3次及以上的元素

思路：

解法与26题类似，再引入一个计数器，26题是元素不相等，就移动元素，快慢指针都+1；如果相等，快指针+1，同时判断计数器，是否第二次相等，如果是第二次，慢指针也+1，然后计数器清零。

##### 88. Merge Sorted Array

思路：

1. 双指针，从前往后：这题比较简单，两个指针进行比较，小的+1，大的不动，小的遍历完，大的剩余直接追加。时间复杂度:O(n+m)，空间复杂度：O(m)
2. 先合并后排序。时间复杂度:O((n+m)log(n+m))，空间复杂度：O(1)
3. 双指针，从后往前：从大的开始比较，大的放最后，然后大的-1。时间复杂度:O(n+m)，空间复杂度：O(1)

#### 数组中的search问题

##### 33. Search in Rotated Sorted Array

题意：给定一个数，判断是否在一个被旋转了一次的有序数组中

思路：

1. 二分查找：先取中间值mid，如果mid等于target，直接返回；如果不等于，则开始判断target是在左边还是右边
2. 先判断右边，mid是否小于right，如果小于，说明右边是有序的；那只要再判断，target是否在[mid,right]之间，如果在，就继续二分查找；如果不在，放弃右边，从左边开始。
3. 循环步骤1.

时间复杂度：O(logN)，空间复杂度：O(1)

##### 34. Find First and Last Position of Element in Sorted Array

题意：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

思路：

有序数组，可以查找肯定用二分

1. 线性扫描：先从左往右扫描，找到第一个target，然后从右往左扫描，找到第一个target。时间复杂度：O(N)，空间复杂度：O(1)
2. 二分查找：如果mid>target或mid==target，high=mid，否则low=mid+1

##### 35. Search Insert Position

题意：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

思路：

1. 整体思路和普通的二分查找几乎没有区别，先设定左侧下标 left 和右侧下标 right，再计算中间下标 mid
2. 每次根据 nums[mid] 和 target 之间的大小进行判断，相等则直接返回下标，nums[mid] < target 则 left 右移，nums[mid] > target 则 right 左移
3. 查找结束如果没有相等值则返回 left，该值为插入位置

时间复杂度：O(logN)

##### 74. Search a 2D Matrix

题意：给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。

思路：

利用二位数组的特性，从左下角或则右上角开始查找，每次nums[x++/--][y++/--]，每次与target比较可以去掉一行或则一列

##### 79. Word Search
##### 81. Search in Rotated Sorted Array II

题意：与33题类似，不过这题的数组元素可能重复。

思路：

如果元素重复，在左边，就直接-1，继续判断找出第一个位置；然后在进行右边查找，就直接+1，继续判断找出最后一个位置

##### 153. Find Minimum in Rotated Sorted Array

思路：

与二分查找类似，如果`mid>right`，则target一定在右边；如果`mid<right`，则target一定在左边

#### 最大最小子数组问题

##### 53. Maximum Subarray

题意：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

##### 152. Maximum Product Subarray
##### 209. Minimum Size Subarray Sum
##### 121. Best Time to Buy and Sell Stock

### Tree

#### 树的遍历问题

##### 94. Binary Tree Inorder Traversal
##### 102. Binary Tree Level Order Traversal
##### 107. Binary Tree Level Order Traversal II
##### 144. Binary Tree Preorder Traversal
##### 145. Binary Tree Postorder Traversal
##### 429. N-ary Tree Level Order Traversal
##### 589. N-ary Tree Preorder Traversal
##### 590. N-ary Tree Postorder Traversal

#### 树的构造问题

### LinkedList

#### 反转单链表

##### 206. Reverse Linked List
##### 92. Reverse Linked List II

题意：反转链表第n到m个节点

思路：插入法，将要反转的节点插入到上一个节点

##### 19. Remove Nth Node From End of List

思路：双指针，快指针先走n步，然后快慢指针一起走，最后将慢指针下一个元素删除。

##### 61. Rotate List
##### 143. Reorder List
##### 234. Palindrome Linked List

题意：判断一个链表是否是回文

思路：将链表转为数组列表，然后通过数组列表进行回文判断

### 