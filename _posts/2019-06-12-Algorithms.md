---
layout: post
title: 数据结构与算法分析入门
category: Algorithms
description: 数据结构和基本算法
---

## 数据结构

### 数组

### 链表

### 队列

### 栈

### 树

### 堆

### 图

## 排序算法

### 冒泡排序

> 从后往前排序，先从最后一个元素开始，一个个的向前比较大小，比前面元素小就交换两者的位置，每比较一轮就能确定一个最小数。

时间查找复杂度为O(n2)。

### 插入排序

> 从第一个元素开始，与后面每一个元素进行比较，记录最小的元素值和位置，比较完一轮后将最小的元素替换到第一位。

时间查找复杂度为O(n2)。

### 选择排序

> 从第一个元素开始，先拿前两个元素进行大小比较，排完序后选择第三个元素开始与前两个已排序的元素比较，以此类推。

时间查找复杂度为O(n2)。

### 堆排序

> 插入有序，构建堆时进行排序，顶节点元素最小。

时间查找复杂度为O(nlogn)。

### 归并排序

> 将数组两两拆分到最小，然后将排好序的数组进行合并。

时间查找复杂度为O(nlogn)。

### 快速排序

> 选择一个元素作为基点，比基点小的放左边，大的放右边。然后再对左边的数组进行排序，选择一个基点，以此类推。

时间查找复杂度为O(nlogn)。

堆排序、归并排序、快速排序数据结构上都是树型，树的深度为logn，所以三个排序的时间查找复杂度都为O(nlogn)

## 查找算法

### 线性查找

> 从第一个元素开始，以此与后面每一个元素进行比较。

时间查找复杂度为O(n2)。

### 二分查找

> 前提：数组是排序的。每次计算中间坐标，比较中间位置元素的大小，小于从左边数组比较，大于从右边数组查找。

时间查找复杂度为O(logn)。

## 图

### 广度优先查找

> 逐层遍历，适合用队列实现，FIFO特性。

### 深度优先查找

> 迭代遍历

### 最小路径查找

> 两种算法实现：贝尔曼-福特算法、迪克斯特拉算法。

## 其它算法

### 最大公约数（欧几里得）

### 素数

### 字符串类算法问题

字符串类相关的算法题：
1. 子串
2. 回文

提示：字符串本质上是一个字符数组，所以字符串类的解题思路要结合数组来考虑。

#### 反转字符串（reverse string）

定义：就是把字符串所有字符倒序。

解题思路：字符串是一个字符数组，可以要实现字符的反转，只要把头尾的字符进行交换即可，只要处理完一半的字符另一半也自然就处理完了。

字符的交换需要一个临时字符变量来存储交换值。

示例：
> 这里要补上代码实现；

#### 回文（palindrome）

定义：回文就是正读和反读都一样的字符串。

解题思路：利用头尾指针，即双指针技术来实现。
> 1. 如果两个指针的字符不相同，直接返回false；
> 2. 如果两个指针的字符相同，同时更新头、尾指针，然后循环比较，直到头、尾指针相遇。

示例：
> 这里要补上代码实现；

#### 前缀树/字典树/单词查找树（Trie Tree）

字典树是一种存储结构，把字符串拆成单个字符，以树的方式存储起来。
> 1. 根节点不包含字符
> 2. 每个节点包含一个字符
> 3. 有相同前缀的单词在同一个前缀节点树下
> 4. 从根节点到某一节点，路径上经过的字符连起来，就是该节点对应的字符串
> 5. 每个节点最多26个子节点（英文26个字符，即树的最大广度为26。）

字典树的两种基本操作分别是建树和查询。建树就是把一个新的单词插入到字典树里，查询操作就是查询给定的单词是否在字典树上。

Trie树注意给定单词的字符长度，如果字符串都非常长（例如64位的MD5）那Trie树的深度会是64层。

#### KMP

KMP适合子串查找，字典树适合全串匹配

## 剑指offer

所有代码实现要分析时间复杂度和空间复杂度。

### 数据结构类

#### LinkedList

8道题

##### 003-从尾到头打印链表

**思路**：

利用栈实现倒序输出，通过遍历链表将每一个节点入栈，然后再遍历输出栈即可。

**代码**：

##### 014-链表中倒数第k个结点

**思路**：

利用双指针（快指针和慢指针），快指针向前移动K个位置，然后快、慢指针一起向前移动，直到快指针为null，慢指针的位置就是第k个节点。

**代码**：

##### 015-反转链表

**思路**：

逐个反转每一个节点。
> 新建一个头节点（newHead），总是指向下一个节点。节点反转需要保存上一个节点（preNode）、下一个节点（nextNode）、当前节点（curNode）

反转做的2个动作：
1. newHead.next = curNode.next; // 头节点指向下一个节点
2. curNode.next = preNode; // 当前节点指向上一个节点
3. preNode = curNode; // 上一节点指向当前节点

**伪代码**

初始化：
newHead.next = head.next; // 新头节点指向下一个节点
preNode.next = null; // 头节点上一个节点为null
head.next = preNode; // 当前节点指向上一个节点

curNode = head.next;

反转：
while(curNode.next != null) {
    newHead.next = curNode.next; // 1.
    curNode.next = preNode; // 2.
    preNode = curNode; // 3.
}

##### 016-合并两个或k个有序链表

**思路**：

两个链表从头开始比较大小，P1小于P2，取出P1，继续P1+与P2比，小的节点+1直到末尾。


##### 025-复杂链表的复制

**复杂链表定义**：单向链表节点，同时节点还有一个额外指针指向任意节点或者null。
> 节点有两个指针，一个next指向下一个节点，另一个sibling指向任意节点。

**思路**：

有3套思路：
第一套，时间复杂度O(n2)
第二套，时间复杂度O(n)，空间复杂度O(n)
第三套，时间复杂度O(n)

目前只理解的第二套：

第一遍正常复制旧链表的next指针节点，遍历链表创建新的链表，同时把旧->新节点存放到HashMap中做映射。

第二遍遍历旧链表的sibling指针节点，到HashMap中根据旧节点找到新节点，直接将新链表的sibling指向新的节点。


##### 036-两个链表的第一个公共节点

**第一个公共节点**：这两个链表后面是共用一个链表。

**思路**：

1. 先计算两个链表长度的差N；
2. 长的链表先走N个节点；
3. 两个链表同时继续遍历走节点，直到两个节点相同。

##### 055-链表中环的入口结点

**思路**：

1. 使用两个指针，一个指针指向链表头节点，另一个指针指向快、慢指针相遇的节点。
2. 两个指针同时出发，直到它们相遇则为入口节点。


**链表环的相关问题**
1. 链表是否有环：通过快、慢指针判断，如果两个指针相遇说明有环（快、慢指针相遇时，慢指针还没有走完）。
2. 如果有环，找环的入口节点
3. 如果有环，求环的节点个数
4. 如果有环，求链表长度

##### 056-删除链表中重复的节点

**思路**：

准备两个指针（快、慢），两指针节点相等，快指针+1，再比较，如果还是相等，快指针继续+1，不相等，慢指针指向快指针位置，快指针+1继续判断。

#### Tree

15道题

**前、中、后序遍历**

这里首先要理解二叉树的前、中、后序遍历，以及如果根据其中两个遍历还原二叉树。
> 预备知识要先知道如何输出一颗树的前、中、后序遍历，然后再根据前、中、后序遍历如何还原。只要先明白了这两个输出和还原就没问题了。

二叉树遍历概念：
- 前序遍历：根、左、右 --> 前序遍历 root {左右子树}
- 中序遍历：左、根、右 --> 中序遍历 {左子树集合} root {右子树集合}
- 后序遍历：左、右、根 --> 后序遍历 {左右子树} root

二叉树还原：
- 前、中序遍历还原
> 1. 前序，第一个节点是根节点（父节点）
> 2. 根据前序确认的根节点，在中序中拆分 {左子树} 根节点 {右子树}
> 3. 把第一颗树就可以画出来了。
> 4. 开始还原 {左子树}，把前序和中序的{左子树}部分单独出来，对{左子树}进行1/2步骤的判断，然后画出3。循环处理{左子树}和{右子树}。
- 中、后序遍历还原
> 1. 后序，最后一个节点是根节点（父节点）
> 2. 根据后序确认的根节点，在中序中拆分 {左子树} 根节点 {右子树}
> 3. 把第一颗树就可以画出来了。
> 4. 开始还原 {左子树}，把后序和中序的{左子树}部分单独出来，对{左子树}进行1/2步骤的判断，然后画出3。循环处理{左子树}和{右子树}。

- 前、后序遍历无法还原，因为无法确认左、右子树

**DFS深度优先查找**

**BFS广度优先查找**

##### 004-重建二叉树

**重建**：根据二叉树的前序、中序顺序还原二叉树。

**思路**：

##### 017-树的子结构

**题意**：判断B树是否是A树的子树

**思路**：
1. 先在A中找到B的根节点R；
2. 然后从R节点开始递归判断AB树的每一个节点是否相等；
> 如果两个节点值不相等直接返回false；
> 如果B树节点为空，返回true；
> 如果A树节点为空，返回false；

##### 018-二叉树的镜像

**题意**：镜像就是所有节点左右翻转，AB - BA

**思路**：
递归将根节点每个左右子节点进行交换。

##### 022-从上往下打印二叉树

**题意**：树的层次遍历

**思路**：
遍历二叉树，使用队列存储，然后输出队列。

##### 023-二叉搜索树的后序遍历序列

**题意**：判断数组是否是某二叉树的后序遍历结果

二叉查找树特点：左子树值 < 根节点值 < 右子树值 

**思路**：
1. 利用二叉查找树的特点，后序遍历最后一位是根节点
2. 遍历数组，查找第一个比根节点值大的位置，则，该位置左边是左子树，右边是右子树。
3. 设计上左子树的值都要把根节点小，右子树的值都要比根节点大。
4. 递归左右子树，执行1/2/3判断。

##### 024-二叉树中和为某一值的路径

**题意**：给定一个值，打印二叉树中节点值和为该值的路径

这是一道DFS深度优先查找，也是一道前序遍历查找。

**思路**：

##### 026-二叉搜索树与双向链表
##### 038-二叉树的深度
##### 039-平衡二叉树
##### 057-二叉树的下一个结点
##### 058-对称的二叉树
##### 059-按之字形顺序打印二叉树
##### 060-把二叉树打印成多行
##### 061-序列化二叉树
##### 062-二叉搜索树的第k个结点


#### Stack&Queue
#### Heap
#### HashTable
#### 图

### 算法类

#### 斐波那契数列
#### 搜索算法
#### 全排列
#### 动态规划
#### 回溯
#### 排序
#### 位运算
#### 其他算法
