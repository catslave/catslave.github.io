---
layout: post
title: 数据结构与算法分析入门
category: Algorithms
description: 数据结构和基本算法
---

# 数据结构

## 数组

## 链表

## 队列

## 栈

## 树

## 堆

## 图

# 排序算法

## 冒泡排序

> 从后往前排序，先从最后一个元素开始，一个个的向前比较大小，比前面元素小就交换两者的位置，每比较一轮就能确定一个最小数。

时间查找复杂度为O(n2)。

## 插入排序

> 从第一个元素开始，与后面每一个元素进行比较，记录最小的元素值和位置，比较完一轮后将最小的元素替换到第一位。

时间查找复杂度为O(n2)。

## 选择排序

> 从第一个元素开始，先拿前两个元素进行大小比较，排完序后选择第三个元素开始与前两个已排序的元素比较，以此类推。

时间查找复杂度为O(n2)。

## 堆排序

> 插入有序，构建堆时进行排序，顶节点元素最小。

时间查找复杂度为O(nlogn)。

## 归并排序

> 将数组两两拆分到最小，然后将排好序的数组进行合并。

时间查找复杂度为O(nlogn)。

## 快速排序

> 选择一个元素作为基点，比基点小的放左边，大的放右边。然后再对左边的数组进行排序，选择一个基点，以此类推。

时间查找复杂度为O(nlogn)。

堆排序、归并排序、快速排序数据结构上都是树型，树的深度为logn，所以三个排序的时间查找复杂度都为O(nlogn)

# 查找算法

## 线性查找

> 从第一个元素开始，以此与后面每一个元素进行比较。

时间查找复杂度为O(n2)。

## 二分查找

> 前提：数组是排序的。每次计算中间坐标，比较中间位置元素的大小，小于从左边数组比较，大于从右边数组查找。

时间查找复杂度为O(logn)。

# 图

## 广度优先查找

> 逐层遍历，适合用队列实现，FIFO特性。

## 深度优先查找

> 迭代遍历

## 最小路径查找

> 两种算法实现：贝尔曼-福特算法、迪克斯特拉算法。

# 其它算法

## 最大公约数（欧几里得）

## 素数

## 字符串类算法问题

字符串类相关的算法题：
1. 子串
2. 回文

提示：字符串本质上是一个字符数组，所以字符串类的解题思路要结合数组来考虑。

### 反转字符串（reverse string）

定义：就是把字符串所有字符倒序。

解题思路：字符串是一个字符数组，可以要实现字符的反转，只要把头尾的字符进行交换即可，只要处理完一半的字符另一半也自然就处理完了。

字符的交换需要一个临时字符变量来存储交换值。

示例：
> 这里要补上代码实现；

### 回文（palindrome）

定义：回文就是正读和反读都一样的字符串。

解题思路：利用头尾指针，即双指针技术来实现。
> 1. 如果两个指针的字符不相同，直接返回false；
> 2. 如果两个指针的字符相同，同时更新头、尾指针，然后循环比较，直到头、尾指针相遇。

示例：
> 这里要补上代码实现；

### 前缀树/字典树/单词查找树（Trie Tree）

字典树是一种存储结构，把字符串拆成单个字符，以树的方式存储起来。
> 1. 根节点不包含字符
> 2. 每个节点包含一个字符
> 3. 有相同前缀的单词在同一个前缀节点树下
> 4. 从根节点到某一节点，路径上经过的字符连起来，就是该节点对应的字符串
> 5. 每个节点最多26个子节点（英文26个字符，即树的最大广度为26。）

字典树的两种基本操作分别是建树和查询。建树就是把一个新的单词插入到字典树里，查询操作就是查询给定的单词是否在字典树上。

Trie树注意给定单词的字符长度，如果字符串都非常长（例如64位的MD5）那Trie树的深度会是64层。

### KMP

KMP适合子串查找，字典树适合全串匹配