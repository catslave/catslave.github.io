
---
layout: post
title: JDK
category: Java多线程技术
description: Java多线程技术包括：线程的实现、线程池技术、多线程同步、线程间通信问题。
---

# Java多线程技术

Java多线程技术主要从以下3个方面展开讲述：
1. 单线程：线程的实现方式、线程提供的基本方法；多线程：线程池实现；
2. 线程同步：同步锁Synchronized、ReentrantLock，无锁实现CAS；
3. 线程通信：Object的wait/notify方法、Lock.condition变量，以及ThreadLocal、Volatile变量；

Java多线程技术还有几个概念：
1. Java内存模型
2. 锁优化
3. 原子性

## 单线程/多线程

Java的线程实现方式有两种，通过继承Thread类或则实现Runnable接口。其中Thread类也是实现了Runnable接口。Thread构造函数接受一个实现了Runnable接口的Runnable对象，通过调用Thread的start方法启动线程，执行run方法。

Thread类常见方法：
1. yield 当前线程让出CPU执行时间片，主动挂起等待。
2. sleep 当前线程休眠指定时间，但是并不会让出CPU执行时间片。
3. start 启动线程，创建一个新的线程，将线程状态更改为Runnable可执行状态，如果获取到了执行权则直接执行。
4. run 执行run方法，不会创建新的线程，使用当前线程执行。
5. interrupt 配合sleep等操作执行，将处于休眠或则等待、挂起的线程自动退出，并释放锁。
6. join 主线程等待子线程执行完。
7. setDaemon 将线程设置为后台线程，不会随着主线程退出而退出

## 线程同步

多线程环境下对共享资源操作会引入线程安全问题，对于共享资源需要做好线程同步操作。线程安全主要通过同步来实现，Java中线程同步的实现方式主要有两种，一种是基于锁实现的同步，比如Synchronized、ReentrantLock，另一种是基于无锁的CAS算法实现。

### Synchronized

Synchronized变量可以作用于方法名、代码块、类名、静态方法等，通过获取对象锁或则类锁来实现线程间同步的。

修饰方法名
> public void synchronized methodA() {};
> public void synchronized methodB() {};

多线程访问同一对象实例的methodA方法只能同步执行，synchronized作用于方法名获取的是对象锁。一个对象只要一个对象锁，所以当一个线程执行methodA方法获取到了当前对象的对象锁后，其他线程执行methodB也要进行等等，直到methodA方法执行完，对象锁被释放。

修饰代码块
> synchronized (object) {}

synchronzied可以直接作用于一段代码块上，通过获取指定对象的对象锁。这个对象可以是当前对象也可以是其他对象。
> 这里要注意，不同对象的对象锁是不会互相影响的，所以一个类的多个方法，获取的是不同对象锁的话，这些方法是可以同时执行的。

修饰静态方法或则静态类
> synchronized (ObjectA.class) {};

一个类只有一个Class对象，所以获取类的锁和静态方法锁是同一个锁，这两个地方的代码是同步的，无法同时执行。

Synchronized是可重入锁
当一个线程获取到了当前对象的对象锁后，可以再次获取该对象的对象锁。
> public void synchronized methodA() { methodB() };
> public void synchronized methodB() {};

Synchronized子类可以获取到父类的锁。


### ReentrantLock

可重入锁，实现了Lock接口，需要手动加解锁，特别是在代码异常情况下一定要释放锁。

ReentrantLock常见方法：
1. lock 加锁
2. tryLock 尝试加锁
3. unlock 解锁
4. newCondition 作用于线程间通信，类似于wait/notify。

### 无锁实现的CAS

上面介绍的基于锁实现的Synchronized和ReentrantLock是Java语言层面提供的解决方案，CAS是硬件层面提供的技术方案，JVM层可以直接调用CAS指令。

## 线程通信

### wait/notify

wait/notify是Object类提供的方法，wait使当前线程挂起进入等待队列并释放锁，notify从等待队列唤醒一个线程进入就绪队列获取锁。notify方法执行完并不会立即释放锁，notify可以调用多次，每次都会唤醒线程，也可以直接调用notifyAll方法唤醒等待队列里的所有线程进入就绪队列。

wait/notify方法执行必须要先获取到当前对象的对象锁，否者会抛异常。

### condition

## Java内存模型

### 内存模型

### volatile

volatitle变量用于解决多个线程之间的变量可见性问题。
> synchronized除了解决同步问题，同时也解决了可见性问题。

### ThreadLocal

线程内的局部变量，内部通过一个map集合实现。

### 原子类型

Atomic基于CAS实现。

## 锁优化

### 锁类型

偏向锁、轻量级锁、重量级锁

### 锁优化