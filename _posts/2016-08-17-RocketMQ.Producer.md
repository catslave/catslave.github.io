---
layout: post
title: RocketMQ In Action - Producer
category: RocketMQ
description: 消息的生产者，负责产生消息。通过Name Server获取到Topic信息，从Topic中选择一个消息队列进行消息发送。根据选择的消息队列，获取该消息队列的Broker地址，然后生产者与该Broker建立连接，将消息发送到Broker上。
---

# RocketMQ.Producer

消息的生产者，负责产生消息。通过Name Server获取到Topic信息，从Topic中选择一个消息队列进行消息发送。根据选择的消息队列，获取该消息队列的Broker地址，然后生产者与该Broker建立连接，将消息发送到Broker上。

消息发送分为同步发送、异步发送、延迟发送和事务发送消息。可以设置发送失败重试次数，这里就可能导致重复发送。

## DefaultMQProducer

一类消息划分为一个Topic，一个Topic包含多条消息队列。生产者在发送消息时，需要指定消息所属的Topic类型，然后根据Topic选择其中一条消息队列进行消息发送。顶级接口`MQAdmin`定义了创建Topic方法。`MQProducer`接口继承`MQAdmin`并定义了发送消息方法。`DefaultMQProducer`实现了`MQProducer接口，作为生产者的默认实现类。

Producer调用start方法启动，DefaultMQProducer调用DefaultMQProducerImpl的start方法，DefaultMQProducerImpl为该生产者创建了一个消息队列客户端实例MQClientInstance，MQClientInstance分别创建了用于客户端远程通信辅助类MQClientAPIImpl、拉取消息服务类PullMessageService（DefaultMQPushConsumerImpl才使用）以及RebalanceService负载均衡服务类（消费者才使用到）。

## Send Message

发送消息需要指定消息所属的Topic，生产者首先根据Topic去Name Server获取Topic的队列信息，如果Topic在Name Server中不存在，Name Server为使用系统默认的Topic消息队列返回给生产者。生产者根据Name Server返回回来的消息队列更新本地的Topic信息表。然后从Topic信息表中选择一条消息队列进行通信。生产者根据消息队列的Broker去Name Server查找该Broker的地址信息。最后与该Broker建立连接，将消息发送给该Broker。
{% highlight java %}
package com.alibaba.rocketmq.client.impl.producer;

public class DefaultMQProducerImpl implements MQProducerInner {
	...

	private SendResult sendDefaultImpl(Message, msg, //...) {
		...

		//1.根据消息设定的Topic查找Topic信息
		TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic);
		...
		//2.从Topic中选择一条消息队列
		MessageQueue tmpmq = topicPublishInfo.selectOneMessageQueue(lastBrokerName);
		//3.调用消息发送方法
		sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);
		...
	}

	private SendResult sendKernelImpl(final Message msg, final MessageQueue mq, //...) {
		//4.根据Broker查找Broker远程地址信息
		String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
		//5.调用消息发送方法
		SendResult sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(
			brokerAddr, // Broker地址
			mq.getBrokerName(),	// Broker名称
			msg, //	消息
			...
			);
		...
	}
}
{% endhighlight %}

{% highlight java %}
package com.alibaba.rocketmq.client.impl;

public class MQClientAPIImpl {
	...

	public SendResult sendMessage(
		final String addr, final String brokerName, final Message msg, ...) {
		...

		//默认采用同步方式发送消息
		return this.sendMessageSync(addr, brokerName, msg, ...);

		...
	}

	private SendResult sendMessageSync(
		final String addr, final String brokerName, final Message msg, ...) {

		//调用Netty客户端往指定addr地址发送消息请求
		RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);
		...
	}

}
{% endhighlight %}

{% highlight java %}
package com.alibaba.rocketmq.remoting.netty;

public class NettyRemotingClient extends NettyRemotingAbstract implements RemotingClient {
	...

	@Override
	public RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis) {
		//根据addr地址获取channel管道，如果不存在则新建channel
		final Channel channel = this.getAndCreateChannel(addr);

		...

		//实际发送消息的地方
		this.invokeSyncImpl(channel, request, timeoutMillis);

		...
	}
}
{% endhighlight %}

{% highlight java %}
package com.alibaba.rocketmq.remoting.netty;

public abstract class NettyRemotingAbstract {
	...

	public RemotingCommand invokeSyncImpl(final Channel channel, final RemotingCommand request,
		final long timeoutMillis) {
		...

		//往管道写入消息并刷新，消息发送完成
		channel.writeAndFlush(request);

		...
	}
}
{% endhighlight %}

## TopicPublishInfo

消息必须属于某个Topic，一个Topic包含多个消息队列，消息队列保存着对应Broker的名称信息。
{% highlight java %}
pakcage com.alibaba.rocketmq.client.impl.producer;

/**
 * Topic信息
 */
public class TopicPublishInfo {
	//保存一个消息队列
	private List<MessageQueue> messageQueueList = new ArrayList<MessageQueue>();
}
{% endhighlight %}
{% highlight java %}
pakcage com.alibaba.rocketmq.common.message;

/**
 * 消息队列信息
 */
public class MessageQueue implements Comparable<MessageQueue>, Serializable {
	//保存Topic名称
	private String topic;
	//保存Broker名称
	private String brokerName;
}
{% endhighlight %}

## Producer

1. 启动了几个线程？如何与Broker/NameServer通信？如何发送消息？绑定了哪些Handler？

Producer启动会创建一个MQClientInstance（Consumer也是创建这个实例），MQClientInstance创建了MQClientAPIImpl用于与服务端通信（这里服务端是指NameServer或Broker）。

MQClientAPIImpl提供了与服务端交互的所有方法：start方法就是启动Netty客户端（NettyRemotingClient）；send方法消息就是调用NettyRemoteClient的invoke方法。

NettyRemoteClient启动1个Worker线程
* eventLoopGroupWorker
* ExecutorService publicExecutor CPU核数对应线程数 ClientCallbackExecutorThreads
* DefaultEventExecutorGroup defaultEventExecutorGroup （clientWorkerThreads = 4，使用这个线程池来处理handler）
* NettyEventExecutor nettyEventExecutor （父类NettyRemotingAbstract线程）

bootstrap pipeline绑定的handler：
* NettyConnectManageHandler 应该是响应连接的，与服务端连接成功后会做什么？这个服务端是指谁？当连接成功后，会被封装成事件然后添加到defaultEventExecutorGroup线程池处理事件？
* NettyClientHandler 处理消息的channelRead0

createChannel的时候才向服务端发起connect请求。

channelTables保存请求IP地址和Channel对应关系。使用ChannelWrapper静态类来封装Channel，Channel的状态通过定义方法直接获取。（这个对Client来说没用，Client的channelEventListener为null，不做任何处理）

2. RocketMQ的消息类型为RemotingCommand

3. 三种发送方式

invokeAsyncImpl -> 构建ResponseFuture，添加到集合responseTable（缓存所有正在发送的请求消息），然后channel.writeAndFlush(request).addListener -> 发送成功将 responseFuture标记为OK。

回调函数什么时候被调用呢？channelRead0到消息后，判断消息类型，如果是Response就是服务端返回的响应，然后根据消息里的ID opaque到responseTable集合找到对应的ReponseFuture，获取绑定的回调函数，提交到

inveokeSyncImpl -> 发送消息后，调用responseFuture.waitResponse(timeoutMills)阻塞等待指定时间。

4. Producer发送完消息就关闭Channel？Channel是什么时候创建、什么时候关闭的？是有维护Channel的心跳？

sync消息发送时间是哪里指定的？配置文件吗？

回调的putResposne是谁来执行的？
由NettyClientHandler来执行

异步回调也是在NettyClientHandler中执行，判断ReponseFuture是否有设置回调函数，如果有就调用回调函数。

为什么不使用线程池？而不是一个addr共用一个连接Channel，而且oneway和async方式要用信号量来控制并发读（因为这两种方式都是只要写就可以，防止过快写导致消息错乱。不是，看了源码，说是为了控制发送数量的，防止内存爆掉，这些都是异步写。），sync却不用？

有点想不明白，这样的模式如何保证高性能的发送消息？

5. NettyRemotingServer是如何处理接收到的消息的？好像是根据code都注册了处理程序和对应的执行线程池？

NettyRemotingServer.registerProcessor
code 就是RequestCode定义的代码，这里的服务端主要是Broker，所以Broker启动后会注册所有的请求类型和处理事件以及线程池。