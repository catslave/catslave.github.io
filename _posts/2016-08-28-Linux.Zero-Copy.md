---
layout: post
title: Linux Zero-Copy
category: Linux
description: Zero-Copy 零拷贝技术，就是避免CPU将数据从一块存储拷贝到另一块存储的技术，减少数据传输过程中发生的用户空间和内核空间的上下文切换带来的开销，从而有效地提高数据传输效率。
---

# Zero-Copy
零拷贝技术，就是避免CPU将数据从一块存储拷贝到另一块存储的技术，减少数据传输过程中发生的用户空间和内核空间的上下文切换带来的开销，从而有效地提高数据传输效率。<br/>

## read/wirte send/recv
在传统的文件传输里面，需要经过多次上下文切换：
{% highlight c++ %}
	read(file, tmp_buf, len);
	write(socket, temp_buf, len);
{% endhighlight %}
以上两行代码是传统的read/write方式进行文件到socket的传输，具体流程如下：
1.调用read函数，文件数据被copy到内核缓冲区
2.read函数返回，文件数据从内核缓冲区copy到用户缓冲区
3.write函数调用，将文件数据从用户缓冲区copy到内核与socket相关的缓冲区
4.数据从socket缓冲区copy到相关协议引擎
在这个过程中，文件数据实际上经过了四次copy操作：硬盘到内核buf，内核buf到用户buf，用户buf到内核socket缓冲区，内核socket缓冲区到协议引擎。<br/>

零拷贝技术就是为了避免数据的多次拷贝：

* 避免内核空间数据拷贝操作
* 避免内核空间和用户空间的数据拷贝操作

## DMA
DMA，Direct Memory Access 直接内存存取，可以在外部设备与内存间直接进行数据交换，而不用通过CPU，这样大大的提高了CPU的利用率。通常系统的总线是由CPU管理的，DMA传输时，CPU让出总数由DMA控制器直接掌管总线。

## mmap
在Linux中，减少拷贝次数的一种方式就是调用`mmap`方法来代替调用`read`方法：<br/>
{% highlight c++ %}
	tmp_buf = mmap(file, len);
	write(socket, tmp_buf, len);
{% endhighlight %}
首先，应用程序调用了`mmap`方法后，数据会先通过DMA拷贝到内核空间缓冲区中。然后，用户空间与内核空间共享这个缓冲区，这样，内核空间和用户空间就不需要再进行一次数据拷贝。接着，应用程序调用了`write`方法，数据直接从原来的内核空间缓冲区拷贝到与socket相关的内核空间缓冲区。最后，数据从内核空间的socket缓冲区拷贝到协议引擎。<br/>
通过使用`mmap`来代替`read`，可以减少操作系统的两次数据拷贝。当大量数据需要传输的时候，这样做就会有一个比较好的效率。但是，使用`mmap`方法也是存在潜在问题的。在对文件进行内存映射后，调用`write`方法，如果此时有其他的进程截断了这个文件，那么`write`方法将会被总线错误信号SIGBUS中断，这个信号将会导致进程被杀死。<br/>

## sendfile
sendfile也是一种减少数据拷贝次数的方式，它还减少为了用户空间和内核空间的上下文切换。
{% highlight c++ %}
#include <sys/sendfile.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
{% endhighlight %}
首先，`sendfile`通过DMA将数据拷贝到内核空间缓冲区中，然后数据被拷贝到与socket相关的缓冲区。最后，DMA将数据从内核空间的socket缓冲区拷贝到协议引擎。<br/>
`sendfile`不需要将数据拷贝或者映射到用户空间中，所以`sendfile`只适用于用户空间不需要对所访问的数据进行处理的情况。相对于`mmap`，因为`sendfile`传输数据没有越过用户空间和内核空间的边界线，所以`sendfile`也极大减少了存储管理的开销。

`sendfile`在两个文件描述符之间直接传递数据，完全在内核中操作，从而避免了内核缓冲区到用户缓冲区的拷贝，因此效率很高，称为零拷贝。

`sendfile`方法参数中的`in_fd`必须是一个支持类似`mmap`函数的文件描述符，即它必须指向真实的文件，不能是`socket`和管道；而`out_fd`必须是一个`socket`。可见，`sendFile`专为网络传输文件而生。`sendfile`系统调用提供了一种减少多次拷贝，提升文件传输性能的方法。

## FileChannel
Java类库通过`java.nio.channels.FileChannel`中的`transferTo`方法使用了零拷贝技术。`transferTo`方法直接将字节从它被调用的通道上传输到另外一个可写字节通道，数据无需流经应用程序。
{% highlight java %}
package java.nio.channels;

public abstract class FileChannel
    extends AbstractInterruptibleChannel
    implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel
{
	...

    /**
     * 将数据从文件通道传输到给定的可写字节通道
     * @param position 需要传输的文件起始位置
     * @param count 传输的最大字节数
     * @param target 目标通道
     */	
	public abstract long transferTo(long position, long count,
                                    WritableByteChannel target)
        throws IOException;
}
{% endhighlight %}
在`transferTo`方法内部，它依赖底层操作系统对零拷贝的支持；在Linux系统中，此调用被传递到`sendfile`系统调用中。
{% highlight c++ %}
#include <sys/sendfile.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
{% endhighlight %}
将数据从一个文件描述符传输到了另一个文件描述符。所以`transferTo`方法也是将用户空间和内核空间的上下文切换次数从四次减少到两次，将数据拷贝从四次减少到三次（其中只有一次涉及到了CPU）。


参考资料：

* [http://www.linuxjournal.com/article/6345](http://www.linuxjournal.com/article/6345)
* [Linux 中的零拷贝技术，第 1 部分](http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/)
* [Linux 中的零拷贝技术，第 2 部分](http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/)
* [通过零拷贝实现有效数据传输](http://www.ibm.com/developerworks/cn/java/j-zerocopy/)
