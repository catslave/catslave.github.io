---
layout: post
title: Linux Zero-Copy
category: Linux
description: Zero-Copy
---

# Zero-Copy

## sendFile
sendFile在两个文件描述符之间直接传递数据，完全在内核中操作，从而避免了内核缓冲区到用户缓冲区的拷贝，因此效率很高，称为零拷贝。
{% highlight c++ %}
#include <sys/sendfile.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
{% endhighlight %}
in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd必须是一个socket。可见，sendFile转为网络传输文件而生。

### read/wirte send/recv
在传统的文件传输里面，需要经过多次上下文切换：<br/>
	read(file, tmp_buf, len);
	write(socket, temp_buf, len);
以上两行代码是传统的read/write方式进行文件到socket的传输，具体流程如下：
1.调用read函数，文件数据被copy到内核缓冲区<br/>
2.read函数返回，文件数据从内核缓冲区copy到用户缓冲区<br/>
3.write函数调用，将文件数据从用户缓冲区copy到内核与socket相关的缓冲区<br/>
4.数据从socket缓冲区copy到相关协议引擎<br/>
在这个过程中，文件数据实际上经过了四次copy操作：硬盘到内核buf，内核buf到用户buf，用户buf到内核socket缓冲区，内核socket缓冲区到协议引擎。<br/>

sendfile系统调用提供了一种减少以上多次copy，提升文件传输性能的方法：<br/>