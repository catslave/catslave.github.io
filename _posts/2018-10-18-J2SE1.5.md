---
layout: post
title: JDK 1.5 更新内容
category: JDK
description: JDK 1.5 更新内容，Concurrent包
---

1.5版本新增加，集合框架新增了Concurrent并发包和Queue队列结构以及Atomic原子类型。

# Queue

{% highlight java %}


{% endhighlight %}

## BlockingQueue

# Concurrent

并发包，里面包含了集合框架的并发解决方案

## ConcurrentHashMap

线程安全的HashMap。实现了ConcurrentMap接口，ConcurrentMap接口新增了一些原子操作方法，putIfAbsent、remove、replace等。

`ConcurrentMap`
{% highlight java %}

// 插入键值对元素时，如果键在map中不存在，则新增键值对；否则获取键在map中的值并返回值。
V putIfAbsent(K key, V value);

// 只有当key和value都在map中存在时才会进行删除，删除成功后返回true，否则不执行删除操作直接返回false。
boolean remove(Object key, Object value);

// 只有当key和value都在map中存在时才会进行替换，替换成功后返回true；否则直接返回false。
boolean replace(K key, V oldValue, V newValue);

// 只有当key在map中存在时才会更新value并返回新的value值，否则返回null。
V replace(K key, V value);

{% endhighlight %}

`ConcurrentHashMap`
{% highlight java %}
public class ConcurrentHashMap<K, V> extends AbstractMap<K, V>
        implements ConcurrentMap<K, V>, Serializable {

	final Segment[] segments;	// 每个segment对象就是一个Entry table[]数组，ConcurrentHashMap将数组再分为为几个段

	static final class HashEntry<K,V> {
        final K key;
        final int hash;
        volatile V value;
        final HashEntry<K,V> next;

        HashEntry(K key, int hash, HashEntry<K,V> next, V value) {
            this.key = key;
            this.hash = hash;
            this.next = next;
            this.value = value;
        }
    }

	// get,put实际操作都封装在Segment
	static final class Segment<K,V> extends ReentrantLock implements Serializable {

		transient volatile HashEntry[] table;	// 每个segment都有一个Entry数组

		V get(Object key, int hash) {
            if (count != 0) { // read-volatile
                HashEntry<K,V> e = getFirst(hash);
                while (e != null) {
                    if (e.hash == hash && key.equals(e.key)) {
                        V v = e.value;
                        if (v != null)
                            return v;
                        return readValueUnderLock(e); // recheck
                    }
                    e = e.next;
                }
            }
            return null;
        }

		// put操作和hashmap的一样，只是在操作前加了锁，以及操作后释放锁
		V put(K key, int hash, V value, boolean onlyIfAbsent) {
            lock();	// 加锁
            try {
                int c = count;
                if (c++ > threshold) // ensure capacity
                    rehash();
                HashEntry[] tab = table;	// put 操作跟hashmap一样
                int index = hash & (tab.length - 1);
                HashEntry<K,V> first = (HashEntry<K,V>) tab[index];
                HashEntry<K,V> e = first;
                while (e != null && (e.hash != hash || !key.equals(e.key)))
                    e = e.next;

                V oldValue;
                if (e != null) {
                    oldValue = e.value;
                    if (!onlyIfAbsent)
                        e.value = value;
                }
                else {
                    oldValue = null;
                    ++modCount;
                    tab[index] = new HashEntry<K,V>(key, hash, first, value);
                    count = c; // write-volatile
                }
                return oldValue;
            } finally {
                unlock();	// 解锁
            }
        }

		// segment内的rehash操作，不是整个segment数组rehash。？？？segment数组好像不会rehash或者调整容量？？？
		void rehash() {
            HashEntry[] oldTable = table;            
            int oldCapacity = oldTable.length;
            if (oldCapacity >= MAXIMUM_CAPACITY)
                return;

            HashEntry[] newTable = new HashEntry[oldCapacity << 1];
            threshold = (int)(newTable.length * loadFactor);
            int sizeMask = newTable.length - 1;
            for (int i = 0; i < oldCapacity ; i++) {	// rehash是在put操作时发生的，put已加锁，所以rehash线程安全
                // We need to guarantee that any existing reads of old Map can
                //  proceed. So we cannot yet null out each bin.
                HashEntry<K,V> e = (HashEntry<K,V>)oldTable[i];

                if (e != null) {
                    HashEntry<K,V> next = e.next;
                    int idx = e.hash & sizeMask;

                    //  Single node on list
                    if (next == null)
                        newTable[idx] = e;

                    else {
                        // Reuse trailing consecutive sequence at same slot
                        HashEntry<K,V> lastRun = e;
                        int lastIdx = idx;
                        for (HashEntry<K,V> last = next;
                             last != null;
                             last = last.next) {
                            int k = last.hash & sizeMask;
                            if (k != lastIdx) {
                                lastIdx = k;
                                lastRun = last;
                            }
                        }
                        newTable[lastIdx] = lastRun;

                        // Clone all remaining nodes
                        for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                            int k = p.hash & sizeMask;
                            HashEntry<K,V> n = (HashEntry<K,V>)newTable[k];
                            newTable[k] = new HashEntry<K,V>(p.key, p.hash,
                                                             n, p.value);
                        }
                    }
                }
            }
            table = newTable;
        }
	}

	public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();

        if (concurrencyLevel > MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;

        // Find power-of-two sizes best matching arguments
        int sshift = 0;
        int ssize = 1;
        while (ssize < concurrencyLevel) {
            ++sshift;
            ssize <<= 1;
        }
        segmentShift = 32 - sshift;
        segmentMask = ssize - 1;
        this.segments = new Segment[ssize];

        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        int c = initialCapacity / ssize;
        if (c * ssize < initialCapacity)
            ++c;
        int cap = 1;
        while (cap < c)
            cap <<= 1;

        for (int i = 0; i < this.segments.length; ++i)
            this.segments[i] = new Segment<K,V>(cap, loadFactor);
    }

	// ConcurrentHashMap 对外提供的get方法，内部实际调用segment的get方法
	public V get(Object key) {
        int hash = hash(key); // throws NullPointerException if key null
        return segmentFor(hash).get(key, hash);	// 根据segment获取key
    }

	// ConcurrentHashMap 对外提供的put方法，内部实际调用segment的put方法
	public V put(K key, V value) {
        if (value == null)
            throw new NullPointerException();
        int hash = hash(key);
        return segmentFor(hash).put(key, hash, value, false);
    }

	final Segment<K,V> segmentFor(int hash) {
        return (Segment<K,V>) segments[(hash >>> segmentShift) & segmentMask];	// 根据key的hash查找在segments数组的位置下标
    }

	// size方法返回map的元素数量，需要统计每个segment的table数量。
    public int size() {
        final Segment[] segments = this.segments;
        long sum = 0;
        long check = 0;
        int[] mc = new int[segments.length];

        for (int k = 0; k < RETRIES_BEFORE_LOCK; ++k) {	// 会尝试两次
            check = 0;
            sum = 0;
            int mcsum = 0;
            for (int i = 0; i < segments.length; ++i) {
                sum += segments[i].count;
                mcsum += mc[i] = segments[i].modCount;
            }
            if (mcsum != 0) {
                for (int i = 0; i < segments.length; ++i) {
                    check += segments[i].count;
                    if (mc[i] != segments[i].modCount) {	// 因为在统计过程中，集合很可能会被修改
                        check = -1; // force retry
                        break;
                    }
                }
            }
            if (check == sum) 
                break;
        }
        if (check != sum) { // size方法会把所有segment都加锁，然后再进行统计，统计完了再一一个释放锁。
            sum = 0;
            for (int i = 0; i < segments.length; ++i) 
                segments[i].lock();
            for (int i = 0; i < segments.length; ++i) 
                sum += segments[i].count;
            for (int i = 0; i < segments.length; ++i) 
                segments[i].unlock();
        }
        if (sum > Integer.MAX_VALUE)
            return Integer.MAX_VALUE;
        else
            return (int)sum;
    }
}

{% endhighlight %}

## CopyOnWriteArrayList

{% highlight java %}



{% endhighlight %}

# Atomic

# Lock