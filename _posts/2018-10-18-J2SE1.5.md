---
layout: post
title: JDK 1.5 更新内容
category: JDK
description: JDK 1.5 更新内容，Concurrent包
---

1.5版本新增加，集合框架新增了Concurrent并发包和Queue队列结构以及Atomic原子类型。

# Queue

Queue接口定义了队列的基本方法，最常用的就是offer和poll方法。

{% highlight java %}

boolean offer(E o);	// 入队 - 新元素添加到队尾

E poll(); // 出队 - 获取队头元素，并将其从队列删除

E remove(); // 删除 - 获取队头元素，并将其从队列删除。如果队列为null，调用该方法会报错。

E peek(); // 获取队列头元素 - 获取队头元素，但不出队

E element(); // 获取队列头元素 - 获取队头元素，但不出队。如果队列为null，调用该方法会报错。

{% endhighlight %}

## BlockingQueue

阻塞队列接口，扩展了Queue方法，并新增了时间控制。

{% highlight java %}

boolean offer(E o, long timeout, TimeUnit unit)	// 入队 - 在指定时间内还未将元素插入队列，则返回false；成功返回true
        throws InterruptedException;	

E poll(long timeout, TimeUnit unit)	// 出队 - 等待一定时间，如果队列为空没有任何元素，则返回null
        throws InterruptedException; 

E take() throws InterruptedException; // 出队 - 一直等待

{% endhighlight %}

## ArrayBlockingQueue

基于数组的有界阻塞队列，提供FIFO先进先出机制。适合场景比如生产者和消费者问题等。

{% highlight java %}

private final E[] items;	// 内部是基于数组存储的

private transient int takeIndex;	// 下一个出队的数组下标

private transient int putIndex;		// 下一个入队的数组下标

private int count;	// 队列长度

private final ReentrantLock lock;	// 读写等操作加锁 ？？？为什么使用一把锁而不是两把？？？

private final Condition notEmpty;	// 告诉其它等待读的线程，队列里面有值了

private final Condition notFull;	// 告诉其它等待写的线程，队列里面有空位了

final int inc(int i) {
        return (++i == items.length)? 0 : i;	// 循环，会用count进行比较，等于count就不允许入队
}

// 入队
public boolean offer(E o) {
	if (o == null) throw new NullPointerException();
	final ReentrantLock lock = this.lock;	// 获取对象锁
	lock.lock();	// 加锁
	try {
		if (count == items.length)	// 如果队列满，返回false
			return false;
		else {
			insert(o);	// 入队
			return true;
		}
	} finally {
		lock.unlock();	// 释放锁
	}
}

// 入队 - 等待一定时间
public boolean offer(E o, long timeout, TimeUnit unit)
	throws InterruptedException {

	if (o == null) throw new NullPointerException();
	final ReentrantLock lock = this.lock;
	lock.lockInterruptibly();	// 加锁，该锁可以被打断
	try {
		long nanos = unit.toNanos(timeout);
		for (;;) {	// 这里为什么要无限循环呢？因为即使notFull被唤醒，也不能保证一定能插入成功，所以在指定时间内会一直尝试。
			if (count != items.length) {	// 如果队列未满，直接插入，结束返回true
				insert(o);
				return true;
			}
			if (nanos <= 0)	// 如果队列满了，且时间小于0直接返会false，插入失败
				return false;
			try {
				nanos = notFull.awaitNanos(nanos);	// 否则还有时间，进入等待，等待指定时间或者被其它线程唤醒。
				// 如果到了指定时间nanos，且notFull信号变量未被其它线程唤醒，awaitNanos就会返回0或负数。
			} catch (InterruptedException ie) {
				notFull.signal(); // propagate to non-interrupted thread
				throw ie;
			}
		}
	} finally {
		lock.unlock();
	}
}

private void insert(E x) {
	items[putIndex] = x;
	putIndex = inc(putIndex);
	++count;
	notEmpty.signal();	// 信号变量，如果有其他线程阻塞在读操作，那么它们将会接收到这个信号，表示队列有已元素可以读了。
}

// 出队
public E poll() {
	final ReentrantLock lock = this.lock;	// 获取锁
	lock.lock();	// 加锁
	try {
		if (count == 0)
			return null;
		E x = extract();
		return x;
	} finally {
		lock.unlock();	// 释放锁
	}
}

// 出队 - 等待一定之间
public E poll(long timeout, TimeUnit unit) throws InterruptedException {
	final ReentrantLock lock = this.lock;
	lock.lockInterruptibly();
	try {
		long nanos = unit.toNanos(timeout);
		for (;;) {
			if (count != 0) {
				E x = extract();
				return x;
			}
			if (nanos <= 0)
				return null;
			try {
				nanos = notEmpty.awaitNanos(nanos);
			} catch (InterruptedException ie) {
				notEmpty.signal(); // propagate to non-interrupted thread
				throw ie;
			}

		}
	} finally {
		lock.unlock();
	}
}

// 出队 - 一直等待
public E take() throws InterruptedException {
	final ReentrantLock lock = this.lock;
	lock.lockInterruptibly();
	try {
		try {
			while (count == 0)	// 无限循环等待
				notEmpty.await();
		} catch (InterruptedException ie) {
			notEmpty.signal(); // propagate to non-interrupted thread
			throw ie;
		}
		E x = extract();
		return x;
	} finally {
		lock.unlock();
	}
}

private E extract() {
	final E[] items = this.items;
	E x = items[takeIndex];	// 获取元素
	items[takeIndex] = null;	// 将队列中该下标的指针置为null
	takeIndex = inc(takeIndex);
	--count;
	notFull.signal();	// 通知其他线程，队列里面有空位了
	return x;
}

public ArrayBlockingQueue(int capacity, boolean fair) {
	if (capacity <= 0)
		throw new IllegalArgumentException();
	this.items = (E[]) new Object[capacity];
	lock = new ReentrantLock(fair);
	notEmpty = lock.newCondition();
	notFull =  lock.newCondition();
}
{% endhighlight %}

## LinkedBlockingQueue

基于链表的阻塞队列，，提供FIFO先进先出机制。

{% highlight java %}

static class Node<E> {	// 链表节点结构
	volatile E item;
	Node<E> next;
	Node(E x) { item = x; }
}

private transient Node<E> head;	// 链表头

private transient Node<E> last;	// 链表尾

private final ReentrantLock takeLock = new ReentrantLock();	// 出队入库分别使用两把锁，ArrayBlockingQueue使用一把

private final ReentrantLock putLock = new ReentrantLock();

private final Condition notEmpty = takeLock.newCondition();

private final Condition notFull = putLock.newCondition();

// 入队
public void put(E o) throws InterruptedException {
	if (o == null) throw new NullPointerException();

	int c = -1;
	final ReentrantLock putLock = this.putLock;	// 获取写锁
	final AtomicInteger count = this.count;
	putLock.lockInterruptibly();
	try {
		try {
			while (count.get() == capacity)	// 如果队列满，则一直等待
				notFull.await();
		} catch (InterruptedException ie) {
			notFull.signal(); // propagate to a non-interrupted thread	？？？为什么两次提醒？？？
			throw ie;
		}
		insert(o);	// 入队
		c = count.getAndIncrement();
		if (c + 1 < capacity)
			notFull.signal();	// 告诉其它线程，队列还有空位
	} finally {
		putLock.unlock();	// 释放锁
	}
	if (c == 0)
		signalNotEmpty();
}

{% endhighlight %}

# Concurrent

并发包，里面包含了集合框架的并发解决方案

## ConcurrentHashMap

线程安全的HashMap。实现了ConcurrentMap接口，ConcurrentMap接口新增了一些原子操作方法，putIfAbsent、remove、replace等。

`ConcurrentMap`
{% highlight java %}

// 插入键值对元素时，如果键在map中不存在，则新增键值对；否则获取键在map中的值并返回值。
V putIfAbsent(K key, V value);

// 只有当key和value都在map中存在时才会进行删除，删除成功后返回true，否则不执行删除操作直接返回false。
boolean remove(Object key, Object value);

// 只有当key和value都在map中存在时才会进行替换，替换成功后返回true；否则直接返回false。
boolean replace(K key, V oldValue, V newValue);

// 只有当key在map中存在时才会更新value并返回新的value值，否则返回null。
V replace(K key, V value);

{% endhighlight %}

`ConcurrentHashMap`
{% highlight java %}
public class ConcurrentHashMap<K, V> extends AbstractMap<K, V>
        implements ConcurrentMap<K, V>, Serializable {

	final Segment[] segments;	// 每个segment对象就是一个Entry table[]数组，ConcurrentHashMap将数组再分为为几个段

	static final class HashEntry<K,V> {
        final K key;
        final int hash;
        volatile V value;
        final HashEntry<K,V> next;

        HashEntry(K key, int hash, HashEntry<K,V> next, V value) {
            this.key = key;
            this.hash = hash;
            this.next = next;
            this.value = value;
        }
    }

	// get,put实际操作都封装在Segment
	static final class Segment<K,V> extends ReentrantLock implements Serializable {

		transient volatile HashEntry[] table;	// 每个segment都有一个Entry数组

		V get(Object key, int hash) {
            if (count != 0) { // read-volatile
                HashEntry<K,V> e = getFirst(hash);
                while (e != null) {
                    if (e.hash == hash && key.equals(e.key)) {
                        V v = e.value;
                        if (v != null)
                            return v;
                        return readValueUnderLock(e); // recheck
                    }
                    e = e.next;
                }
            }
            return null;
        }

		// put操作和hashmap的一样，只是在操作前加了锁，以及操作后释放锁
		V put(K key, int hash, V value, boolean onlyIfAbsent) {
            lock();	// 加锁
            try {
                int c = count;
                if (c++ > threshold) // ensure capacity
                    rehash();
                HashEntry[] tab = table;	// put 操作跟hashmap一样
                int index = hash & (tab.length - 1);
                HashEntry<K,V> first = (HashEntry<K,V>) tab[index];
                HashEntry<K,V> e = first;
                while (e != null && (e.hash != hash || !key.equals(e.key)))
                    e = e.next;

                V oldValue;
                if (e != null) {
                    oldValue = e.value;
                    if (!onlyIfAbsent)
                        e.value = value;
                }
                else {
                    oldValue = null;
                    ++modCount;
                    tab[index] = new HashEntry<K,V>(key, hash, first, value);
                    count = c; // write-volatile
                }
                return oldValue;
            } finally {
                unlock();	// 解锁
            }
        }

		// segment内的rehash操作，不是整个segment数组rehash。？？？segment数组好像不会rehash或者调整容量？？？
		void rehash() {
            HashEntry[] oldTable = table;            
            int oldCapacity = oldTable.length;
            if (oldCapacity >= MAXIMUM_CAPACITY)
                return;

            HashEntry[] newTable = new HashEntry[oldCapacity << 1];
            threshold = (int)(newTable.length * loadFactor);
            int sizeMask = newTable.length - 1;
            for (int i = 0; i < oldCapacity ; i++) {	// rehash是在put操作时发生的，put已加锁，所以rehash线程安全
                // We need to guarantee that any existing reads of old Map can
                //  proceed. So we cannot yet null out each bin.
                HashEntry<K,V> e = (HashEntry<K,V>)oldTable[i];

                if (e != null) {
                    HashEntry<K,V> next = e.next;
                    int idx = e.hash & sizeMask;

                    //  Single node on list
                    if (next == null)
                        newTable[idx] = e;

                    else {
                        // Reuse trailing consecutive sequence at same slot
                        HashEntry<K,V> lastRun = e;
                        int lastIdx = idx;
                        for (HashEntry<K,V> last = next;
                             last != null;
                             last = last.next) {
                            int k = last.hash & sizeMask;
                            if (k != lastIdx) {
                                lastIdx = k;
                                lastRun = last;
                            }
                        }
                        newTable[lastIdx] = lastRun;

                        // Clone all remaining nodes
                        for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                            int k = p.hash & sizeMask;
                            HashEntry<K,V> n = (HashEntry<K,V>)newTable[k];
                            newTable[k] = new HashEntry<K,V>(p.key, p.hash,
                                                             n, p.value);
                        }
                    }
                }
            }
            table = newTable;
        }
	}

	public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();

        if (concurrencyLevel > MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;

        // Find power-of-two sizes best matching arguments
        int sshift = 0;
        int ssize = 1;
        while (ssize < concurrencyLevel) {
            ++sshift;
            ssize <<= 1;
        }
        segmentShift = 32 - sshift;
        segmentMask = ssize - 1;
        this.segments = new Segment[ssize];

        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        int c = initialCapacity / ssize;
        if (c * ssize < initialCapacity)
            ++c;
        int cap = 1;
        while (cap < c)
            cap <<= 1;

        for (int i = 0; i < this.segments.length; ++i)
            this.segments[i] = new Segment<K,V>(cap, loadFactor);
    }

	// ConcurrentHashMap 对外提供的get方法，内部实际调用segment的get方法
	public V get(Object key) {
        int hash = hash(key); // throws NullPointerException if key null
        return segmentFor(hash).get(key, hash);	// 根据segment获取key
    }

	// ConcurrentHashMap 对外提供的put方法，内部实际调用segment的put方法
	public V put(K key, V value) {
        if (value == null)
            throw new NullPointerException();
        int hash = hash(key);
        return segmentFor(hash).put(key, hash, value, false);
    }

	final Segment<K,V> segmentFor(int hash) {
        return (Segment<K,V>) segments[(hash >>> segmentShift) & segmentMask];	// 根据key的hash查找在segments数组的位置下标
    }

	// size方法返回map的元素数量，需要统计每个segment的table数量。
    public int size() {
        final Segment[] segments = this.segments;
        long sum = 0;
        long check = 0;
        int[] mc = new int[segments.length];

        for (int k = 0; k < RETRIES_BEFORE_LOCK; ++k) {	// 会尝试两次
            check = 0;
            sum = 0;
            int mcsum = 0;
            for (int i = 0; i < segments.length; ++i) {
                sum += segments[i].count;
                mcsum += mc[i] = segments[i].modCount;
            }
            if (mcsum != 0) {
                for (int i = 0; i < segments.length; ++i) {
                    check += segments[i].count;
                    if (mc[i] != segments[i].modCount) {	// 因为在统计过程中，集合很可能会被修改
                        check = -1; // force retry
                        break;
                    }
                }
            }
            if (check == sum) 
                break;
        }
        if (check != sum) { // size方法会把所有segment都加锁，然后再进行统计，统计完了再一一个释放锁。
            sum = 0;
            for (int i = 0; i < segments.length; ++i) 
                segments[i].lock();
            for (int i = 0; i < segments.length; ++i) 
                sum += segments[i].count;
            for (int i = 0; i < segments.length; ++i) 
                segments[i].unlock();
        }
        if (sum > Integer.MAX_VALUE)
            return Integer.MAX_VALUE;
        else
            return (int)sum;
    }
}

{% endhighlight %}

## CopyOnWriteArrayList

线程安全的ArrayList，写操作同步并且每次写都会新创建一个数组，读操作支持并发读的是旧的数组。所以对于写少读多的场景适合，且是一个线程安全的列表。ArrayList线程不安全的，所以读效率是一样的，但是并发写会出问题。

{% highlight java %}

private volatile transient E[] array;

public CopyOnWriteArrayList() {
	array = (E[]) new Object[0];	// 初始化的时候创建了一个容量为1的数组
}

// 添加元素到列表中，该方法是同步的
public synchronized boolean add(E element) {
	int len = array.length;
	E[] newArray = (E[]) new Object[len+1];	// 创建了一个新的数组，每次add的时候都扩容一次
	System.arraycopy(array, 0, newArray, 0, len);
	newArray[len] = element;
	array = newArray;	// array指向新的数组
	return true;
}

// 将元素添加到指定位置
public synchronized void add(int index, E element) {
	int len = array.length;
	if (index > len || index < 0)
		throw new IndexOutOfBoundsException("Index: "+index+", Size: "+len);

	E[] newArray = (E[]) new Object[len+1];	// 创建新的数组
	System.arraycopy(array, 0, newArray, 0, index);	// 将指定位置前的元素拷贝到新数组
	newArray[index] = element;	// 将元素添加到指定位置
	System.arraycopy(array, index, newArray, index+1, len - index);	// 将指定位置后的元素拷贝到新数组
	array = newArray;
}

// 获取指定位置的元素
public E get(int index) {
	E[] elementData = array();	// 添加对数组的引用，这时候如果有add操作，add是新创建一个数组，所以这里不会冲突。
	rangeCheck(index, elementData.length);
	return elementData[index];
}
{% endhighlight %}

# Atomic

# Lock