---
layout: post
title: RocketMQ Consumer
category: RocketMQ
description: 消费者，消费消息。生产者将消息发送到Broker，Broker存储消息并将消息转发给消费者，消费者接收消息然后处理消息。消费者也可以订阅指定主题的消息，Broker收到该主题的消息后会主动将消息推送给已订阅的消费者。
---

# RocketMQ.Consumer
消费者，消费消息。生产者将消息发送到Broker，Broker存储消息并将消息转发给消费者，消费者接收消息然后处理消息。消费者也可以订阅指定主题的消息，Broker收到该主题的消息后会主动将消息推送给已订阅的消费者。

## Subscribe
创建一个新的消费者，可以给该消费者订阅某个Topic下的消息，然后为消费者添加消息处理程序，当有新消息到来时，自动调用消息处理程序处理消息。

消费者默认有两种实现，`DefaultMQPushConsumer`和`DefaultMQPullConsumer`。`DefaultMQPushConsumer`类型消费者采用订阅的方式，订阅某个Topic，当Broker有这类Topic新消息时会主动推送给这类消费者。`DefaultMQPullConsumer`类型消费者，自己主动轮询监听是否有最新的消息。默认我们使用`DefaultMQPushConsumer`类型消费者。

消费者订阅Topic消息，`DefaultMQPushConsumerImpl`将订阅消息封装成`SubscriptionData`，保存到订阅队列中，最后更新Broker的订阅服务列表。Broker收到消息后，根据订阅服务列表过滤出订阅者，然后将消息发送给指定的订阅者进行消费。
{% highlight java %}
package com.alibaba.rocketmq.client.impl.consumer;

public class DefaultMQPushConsumerImpl implements MQConsumerInner {
	...

  	/**
	 * 订阅Topic
     * @param topic Topic名称
     * @param subExpression 过滤表达式
     * @throws MQClientException
     */
	public void subscribe(String topic, String subExpression) throws MQClientException {

		//将topic封装成订阅信息 SubscriptionData
		SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
			topic, subExpression);
		//将订阅信息保存到订阅服务队列中
		this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
		if(this.mQClientFactory != null) {
			//发现心跳消息以及更新Broker的订阅列表
			this.mQClientfactory.sendHeartbeatToAllBrokerWithLock();
		}
	}
}
{% endhighlight %}
{% highlight java %}
package com.alibaba.rocketmq.client.impl.factory;

public class MQClientInstance {
	...

	public void sendHeartbeatToAllBrokerWithLock() {
		...
		//发送心跳检查
		this.sendHeartbeatToAllBroker();
		//更新Broker的订阅服务列表
		this.uploadFilterClassSource();
		...
	}

	public void uploadFilterClassSource() {
		....

		this.uploadFilterClassSourceToAllFilterServer(
			consumerGroup, className, topic, filterClassSource);

		...
	}

	public void uploadFilterClassSourceToAllFilterServer(
		final String consumerGroup, final String fullClassName, final String topic,
		final String filterClassSource) throws UnsupportedEncodingException {
		...

		this.mQClientAPIImpl.registerMessageFilterClass(fsAddr, consumerGroup, topic, fullClassName, ...);

		...
	}
}
{% endhighlight %}
{% highlight java %}
package com.alibaba.rocketmq.client.impl;

public class MQClientAPIImpl {
	...

	public void registerMessageFilterClass(final String addr,
		final String consumerGroup,
		final String topic,
		final String className,
		...) {

		...

		//设置请求消息类型为REGISTER_MASTER_FILTER_CLASS
		RemotingCommand.createRequestCommand(RequestCode.REGISTER_MASTER_FILTER_CLASS, requestHeader);
		//发送消息事件到Broker，更新Broker的订阅服务列表
		this.remotingClient.invokeSync(addr, request, timeoutMillis);

		...
	}
}
{% endhighlight %}
## Rebalance Service
消费者启动后，开启`RebalanceService`平衡服务，定时调用客户端实例`MQClientInstance`的`doRebalance`方法。`doRebalance`方法遍历当前消费者的所有Topic列表，每个Topic调用`rebalanceByTopic`方法。`rebalanceByTopic`方法获取Topic的所有消息队列集合`Set<MessageQueue>`。然后调用`updateProcessQueueTableInRebalance`方法更新当前的消息处理队列集合，从消息处理队列集合中移除过期无用的消息队列ProcessQueue，ProcessQueue是MessageQueue的消费快照。将新的消息队列加入到消息处理队列集合中。然后调用`dispatchPullRequest`方法将消息请求加入请求队列`pullRequestQueue`。<br/>

`PullMessageService`长轮询`pullRequestQueue`，一旦有新的请求加入队列将处理请求。调用`NettyRemotingClient`发送`PULL_MESSAGE`请求。
{% highlight java %}
package com.alibaba.rocketmq.client.impl.factory;

public class MQClientInstance {
	...

	//开启平衡服务
	this.rebalanceService.start();

	...
}
{% endhighlight %}
{% highlight java %}
package com.alibaba.rocketmq.client.impl.consumer;

public class RebalanceService extends ServiceThread {
	...

	@Override
	public void run() {

		//定期执行doRebalance方法
		while(!this.isStoped) {
			this.waitForRunning(WaitInterval);
			this.mqClientFactory.doRebalance();
		}
	}

	...
}
{% endhighlight %}
{% highlight java %}
package com.alibaba.rocketmq.client.impl.consumer;

public abstract class RebalanceImpl {
	...

	public  boolean updateProcessQueueTableInRebalance(final String topic, fianl Set<MessageQueue> mqSet) {
		...

		//1.移除过期无用的MessageQueue
		if(!mqSet.contains(mq)) {
			this.removeUnnecessaryMessageQueue(mq, pq);
		} else if (pq.isPullExpired) {
			this.removeUnnecessaryMessageQueue(mq, pq);
		}
		//2.将新增的MessageQueue加入ProcessQueueTable消息处理队列集合中
		this.processQueueTable.put(mq, pullRequest.getProcessQueue());
		//3.将MessageQueue封装成PullRequest请求，然后发起请求
		this.dispatchPullRequest(pullRequestList);
	}

	...
}
{% endhighlight %}
{% highlight java %}
package com.alibaba.rocketmq.client.impl.consumer;

public class PullMessageService extends ServiceThread {
	...

	public void executePullRequestImmediately(fianl PullRequest pullRequest) {
		//将请求加入请求队列中
		this.pullRequestQueue.put(pullRequest);
	}

	@Override
	public void run() {

		while(!this.isStoped) {
			//一直轮询监听请求队列
			PullRequest pullRequest = this.pullRequestQueue.take();
			if(pullRequest != null) {
				//当一有新请求加入队列时，就处理该请求
				this.pullMessage(pullReuqest);
			}
		}
	}
}
{% endhighlight %}
## Consume Message
消费者成功发送消息请求后，Broker接收到该请求，根据请求的Topic和QueueId获取消息，然后将消息发送给消费者。消费者接收到消息后，回调已注册的消息处理程序`PullCallBack`消费消息。

`PullCallBack`接收到消息响应后，将消息响应提交到`ConsumeMessageConcurrentlyService`服务类，`ConsumeMessageConcurrentlyService`将消息响应封装成一个`ConsumeRequest`Task任务提交到线程池`consumeExecutor`中执行。`ConsumeRequest`回调消费者自定义的消息处理程序，由该程序处理消息。
{% highlight java %}
package com.alibaba.rocketmq.client.impl.consumer;

public class DefaultMQPushConsumerImpl implements MQConsumerInner {
	...

	/**
     * 消费者注册自定义消息处理程序，当接收到新消息时会回调用该处理程序
     * 处理消息。
     * @param messageListener
     */
    public void registerMessageListener(MessageListener messageListener) {
        this.messageListenerInner = messageListener;
    }

    public void pullMessage(final PullRequest pullRequest) {

    	...

    	//消息请求回调方法
    	PullCallback pullCallback = new PullCallback() {

    		@Override
    		public void onSuccess(PullResult pullRequest) {
    			...

    			DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(
    				pullResult.getMsgFoundList(),
    				processQueue,
    				pullRequest.getMessageQueue(),
    				dispathToConsume
    				);

    			...
    		}

    	}

    	...
    }
}
{% endhighlight %}
{% highlight java %}
package com.alibaba.rocketmq.client.impl.consumer;

public class ConsumeMessageConcurrentlyService implements ConsumeMessageService {
	...

	@Override
	public void submitConsumeRequest(final List<MessageExt> msgs, ...) {
		...
		//1.将消息响应封装成一个Task任务
		ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);
		//2.将该任务提交到线程池
		this.consumeExecutor.submit(consumeRequest);
		...
	}

	class ConsumeRequest implements Runnable {
		...

		@Override
		public void run() {
			//用户自定义的消息处理回调方法
			MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.this.messageListener;
			//调用用户自定义的方法
			status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);
		}

		...

	}
}
{% endhighlight %}