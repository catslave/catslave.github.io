---
layout: post
title: Motan In Action - Provider
category: Motan
description: Provider
---

# Transactional

## 配置不全

## 配置加载顺序

## MySql 存储引擎不支持事务

* MyISAM 适用于查询，不支持事务处理
* InnoDB 支持事务处理

## 配置概述
Motan框架中将功能模块抽象为四个可配置的元素，分别为：
* protocol
* registry
* service
* referer

Motan推荐使用Spring配置RPC服务，Motan扩展了一些自定义的Spring xml标签。项目运行时通过加载配置文件启动Motan。
* motan:protocol 配置Motna服务的协议，不同的服务适用不同的协议进行传输，可以自行扩展协议。Motan默认的RPC协议为Motan协议，使用TCP长连接模式，基于Netty通信。协议还包括负责均衡、容错策略、连接控制、本地调用等属性。
* motan:registry 注册中心配置。用于配置注册中心的注册协议、地址端口、超时时间等。Motan支持使用多种Registry模块，如Consul、Zookeeper，使用不同注册中心需要依赖对应的jar包。在开发及测试环境下，也可以不使用注册中心，只测试指定服务提供者。
* motan:service 定义给外部调用的接口。
* motan:basicService RPC服务的通用配置，用于配置所有服务接口的公共配置，减少配置冗余。
* motan:referer 服务调用方。Client端订阅Service后，会从Registry中得到能够提供对应Service的一组Server，Client把这一组Server看作一个提供服务的cluster。当cluster中的Server发送变更时，Client端的register模块会通知Client进行更新。
* motan:basicReferer 调用方基础配置。用于配置所有服务代理的公共属性。

### Service
motan:service的export属性，暴露服务并将服务注册至注册中心，从而使调用方调用。

ServiceConfig的export方法，为同步方法防止服务被多次暴露。方法首先判断服务是否已发布，如果已发布则直接结束。接着检查所要发布服务的方法和接口是否存在和正确。然后加载注册中心配置和服务协议配置，将服务发布到注册中心所指定的地址和端口。一个服务可以发布到注册中心的多地址。服务发布成功后，将服务添加到已注册服务列表中，确保服务唯一。
{% highlight java %}
public synchronized void export() {
	// 检查服务是否已发布
	if(export.get()) {
		LoggerUtil.warn(String.format("%s has already been expoted, so ignore the export request!", interfaceClass.getName()));
		return;
	}

	// 检查发布服务的接口和方法是否存在和正确
	checkInterfaceAndMethods(interfaceClass, methods);

	// 加载注册中心配置地址 Zookeeper或者Consul服务地址
	List<URL> registryUrls = loadRegistryUrls();
	if(registryUrls == null || registryUrls.size() == 0) {
		throw new IllegalStateException("Should set registry config for service:" + interfaceClass.getName());
	}

	// 加载服务协议配置的服务发布地址和端口
	Map<String, Integer> protocolPorts = getProtocolAndPort();
	// protocols 哪里来的？？？ServiceConfigBean里创建，实现了InitializingBean接口的afterPropertiesSet方法
	for(ProtocolConfig protocolConfig : protocols) {
		Integer port = protocolPorts.get(protocolConfig.getId());
		if(port == null) {
			throw new MotanServiceException(String.format("Unknow port in service:%s, protocol:%s", interfaceClass.getName(),
                        protocolConfig.getId()));
		}
		// 发布服务
		doExport(protocolConfig, port, registryUrls);
	}

	// 将服务添加到已注册服务列表
	afterExport();
}
{% endhighlight %}
1.这里还有很多问题要思考：点对点配置，直接export，配置文件如何加载？采用公共配置，配置文件如何加载？这里还需要进一步分析。目前分析的这个流程是采用哪种配置方式？
2.已经找到源头，在ServiceConfigBean文件里查找。

ServiceConfig的内部方法doExport，首先对参数进行一些默认设置，然后构建服务的URL地址，最后通过`ConfigHandler`发布服务。
{% highlight java %}
private void doExport(ProtocolConfig protocolConfig, int port, List<URL> registryUrls) {
	String protocolName = protocolConfig.getName();
	if(protocolName == null || protocolName.length() == 0) {
		protocolName = URLParamType.protocol.getValue();// 默认协议“motan”
	}

	// 设置本地IP
	String hostAddress = host;
	if(StringUtils.isBlank(hostAddress) && basicServiceConfig != null) {
		hostAddress = basicServiceConfig.getHost();
	}
	if(NetUtils.isInvalidLocalHost(hostAddress)) {
		hostAddress = getLocalHostAddress(registryUrls);
	}

	Map<String, String> map = new HashMap<String, String>();

	map.put(URLParamType.nodeType.getName(), MotanConstants.NODE_TYPE_SERVICE);
	map.put(URLParamType.refreshTimestamp.getName(), String.valueOf(System.currentTimeMillis()));

	// 加载配置文件参数
	collectConfigParams(map, protocolConfig, basicServiceConfig, extConfig, this);
	collectMethodConfigParams(map, this.getMethods());

	// 构建服务URL
	URL serviceUrl = new URL(protocolName, hostAddress, port, interfaceClass.getName(), map);

	if(serviceExists(serviceUrl)) {
		LoggerUtil.warn(String.format("%s configService is malformed, for same service (%s) already exists ", interfaceClass.getName(),
                    serviceUrl.getIdentity()));
            throw new MotanFrameworkException(String.format("%s configService is malformed, for same service (%s) already exists ",
                    interfaceClass.getName(), serviceUrl.getIdentity()), MotanErrorMsgConstant.FRAMEWORK_INIT_ERROR);
	}

	List<URL> urls = new ArrayList<URL>();

	// injvm 协议只支持注册到本地，其他协议可以注册到local、remote
	if(MotanConstants.PROTOCOL_INJVM.equals(protocolConfig.getId())) {
		...
	} else {
		for (URL ru : registryUrls) {
			urls.add(ru.createCopy());// 为什么要copy？？？
		}
	}

	for(URL u : urls) {
		u.addParameter(URLParamType.embed.getName(), StringTools.urlEncode(serviceUrl.toFullStr()));
		registereUrls.add(u.createCopy());// ??? registereUrls
	}

	// 获取默认配置处理程序，发布服务 ？？？SimpleConfigHandler
	ConfigHandler configHandler = ExtensionLoader.getExtensionLoader(ConfigHelper.class).getExtension(MotanConstants.DEFAULT_VALUE);

	exporters.add(configHandler.export(interfaceClass, ref, urls));

	// 记录服务，用于日志统计作用
	initLocalAppInfo(serviceUrl);

}
{% endhighlight %}

`ConfigHandler`接口定义了处理配置文件中URL的基本方法，包括export、unexport、refer等泛型方法。`SimpleConfigHandler`为`ConfigHandler`的简单实现类。`ServiceConfig`的`doExport`方法，最终调用`ConfigHandler.export`方法发布服务，`SimpleConfigHandler`实现了`ConfigHandler`的`export`方法，方法的实现非常简单，第一启动服务，第二将服务发布到注册中心。
{% highlight java %}
@Override
public <T> Exporter<T> export(Class<T> interfaceClass, T ref, List<URL> registryUrls) {
	
	String serviceStr = StringTools.urlDecode(registryUrls.get(0).getParameter(URLParamType.embed.getName()));
	URL serviceUrl = URL.valueOf(serviceStr);

	// export Service 启动服务
	// 利用protocol decorator来增加filter特性
	String protocolName = serviceUrl.getParameter(URLParamType.protocol.getName(), URLParamType.protocol.getValue());
	Protocol protocol = new ProtocolFilterDecorator(ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(protocolName));
	// Provider ???
	Provider<T> provider = new DefaultProvider<T>(ref, serviceUrl, interfaceClass);
	Exporter<T> exporter = protocol.export(provider, serviceUrl);// ？？？

	// register service 注册服务
	register(registryUrls, serviceUrl);

	return exporter;
}
{% endhighlight %}

抽象类`AbstractProtocol`实现了`Protocol`接口定义的`export`方法。`AbstractProtocol`内部维护着一张`exporterMap`，`protocolKey`与`exporter`的对应关系。在`export`方法的实现中，使用`synchronized`关键字对`exporterMap`加锁，确保服务唯一。
{% highlight java %}
@Override
public <T> Exporter<T> export(Provider<T> provider, URL url) {

	// 检查参数
	if(url == null)	{
		throw new MotanFrameworkException(this.getClass().getSimpleName() + " export Error: url is null", MotanErrorMsgConstant.FRAMEWORK_INIT_ERROR);
	}

	if(provider == null) {
		throw new MotanFrameworkException(this.getClass().getSimpleName() + " export Error: provider is null, url=" + url, MotanErrorMsgConstant.FRAMEWORK_INIT_ERROR);
	}

	// ???
	String protocolKey = MotanFrameworkUtil.getProtocolKey(url);

	synchronized(exporterMap) {
		Exporter<T> exporter = (Exporter<T>)exporterMap.get(protocolKey);

		if(exporter != null) {
			throw new MotanFrameworkException(this.getClass().getSimpleName() + " export Error: service already exist, url=" + url, MotanErrorMsgConstant.FRAMEWORK_INIT_ERROR);
		}

		// 创建服务
		exporter = createExporter(provider, url);
		exporter.init();

		exporterMap.put(protocolKey, exporter);

		LoggerUtil.info(this.getClass().getSimpleName() + " export Success: url=" + url);

		return exporter;
	}
}
{% endhighlight %}
`DefaultRpcProtocol`继承`AbstractProtocl`，实现`createExporter`和`createReferer`方法，并定义了两个内部类`DefaultRpcExporter`和`DefaultRpcReferer`。
{% highlight java %}
@Override
protected <T> Exporter<T> createExporter(Provider<T> provider, URL url) {
	return new DefaultRpcExporter<T>(provider, url);
}
{% endhighlight %}
{% highlight java %}
	class DefaultRpcExporter<T> extends AbstractExporter<T> {
		private Server server;
		private EndpointFactory endpointFactory;

		public DefaultRpcExporter(Provider<T> provider, URL url) {
			super(provider, url);

			// 构建消息处理程序，用于方法的回调
			ProviderMessageRouter requestRouter = initRequestRouter(url);
			
			endpointFactory = ExtensionLoader.getExtensionLoader(EndpointFactory.class).getExtension(url.getParameter(URLParamType.endpointFactory.getName(), URLParamType.endpointFactory.getValue()));
			// 启动Netty Server服务
			server = endpointFactory.createServer(url, requestRouter);
		}
	}
{% endhighlight %}
`NettyEndpointFactory`创建了`NettyServer`实例，启动了一个Netty服务端。
















