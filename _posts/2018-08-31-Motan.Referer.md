---
layout: post
title: Motan Referer
category: Motan
description: Referer
---

# proxy
动态代理实现

动态代理原理分析：Java动态代理最终也是动态生成class字节码文件，然后加载运行。
因为JVM不允许在运行时修改原有类，所以所有的动态性都是通过新建类来实现的。 引出一个问题：JVM 动态更新

Java动态代理的两种实现方法JDK和CGLib https://blog.csdn.net/m0_38039437/article/details/77970633
JDK动态代理实现原理 http://rejoy.iteye.com/blog/1627405

* 静态代理是通过在代码中显式定义一个业务实现类一个代理，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；
* JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；
* CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；

# Serialize
* 单例反射问题 readResolve
* 有些序列化方式支持字段的增删

# rpc

## GenericObjectPool

## JDK Execute
* Executor
* ExecutorService
* AbstractExecutorService
* ThreadPoolExecutor

### ThreadPoolExecutor
1. corePoolSize,maximumPoolSize 线程池会根据corePoolSize和maximumPoolSize两个参数自动调整线程池的大小。通过submit或execute方法提交任务的时候，如果当前线程池的线程数小于corePoolSize，线程池就会创建一个新的线程处理任务，即使其他的core线程是空闲的。如果当前线程池的线程数大于corePoolSize并且小于maximumPoolSize，那么只有在队列“满”的情况下才会创建新的线程。因此这里有一个注意事项，如果希望请求积压在队列的时候能够自动扩容，但指定的队列又是一个无界队列，那么就不会扩容，因为队列不存在“满”的情况。
2. keepAliveTime 如果当前线程池数超过corePoolSize，那么如果在keepAliveTime事件内都没有新的任务需要处理，超过corePoolSize的那部分线程就会被销毁。默认情况下是不会回收corePoolSize线程，可以通过设置allowCoreThreadTimeOut改变这一行为。
3. workQueue 实际用于存储任务的队列。如果传入的是一个有界队列，那么队列满的时候，线程池就会根据core和max参数决定是否需要扩容。
4. threadFactory 创建线程是通过ThreadFactory来实现的，如果没有指定，默认是使用Executors.defaultThreadFactory()。一般来说，我们会在这里对线程设置名称、异常处理器等等。
5. handler 任务提交失败的时候会调用这个处理器。ThreadPoolExecutor内置了多个实现，比如抛异常、直接抛弃等。这里可以根据业务场景需要进行配置，比如当队列积压的时候，针对性的对线程池进行扩容或者发送警告等策略。

### commons-pool
* ObjectPool 对象池，定义基础方法，获取对象、归还对象、添加对象。
* PooledObjectFactory 对ObjectPool方法的补充，创建池中的对象和销毁对象。
* ObjectPoolFactory 对象池的工厂类，用于创建对象池


# Question
* Motan如何实现高并发、高可用？











